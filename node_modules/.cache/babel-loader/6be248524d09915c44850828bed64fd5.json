{"ast":null,"code":"import _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Matrix3, Vector2, Vector3, ShapeUtils, Box2, Shape, Path, BufferGeometry, Float32BufferAttribute, ShapePath } from 'three';\n\nvar SVGLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(SVGLoader, _Loader);\n\n  var _super = _createSuper(SVGLoader);\n\n  function SVGLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, SVGLoader);\n\n    _this = _super.call(this, manager); // Default dots per inch\n\n    _this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n    _this.defaultUnit = 'px';\n    return _this;\n  }\n\n  _createClass(SVGLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var scope = this;\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        var transform = getNodeTransform(node);\n        var traverseChildNodes = true;\n        var path = null;\n\n        switch (node.nodeName) {\n          case 'svg':\n            break;\n\n          case 'style':\n            parseCSSStylesheet(node);\n            break;\n\n          case 'g':\n            style = parseStyle(node, style);\n            break;\n\n          case 'path':\n            style = parseStyle(node, style);\n            if (node.hasAttribute('d')) path = parsePathNode(node);\n            break;\n\n          case 'rect':\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n\n          case 'polygon':\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n\n          case 'polyline':\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n\n          case 'circle':\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n\n          case 'ellipse':\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n\n          case 'line':\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n\n          case 'defs':\n            traverseChildNodes = false;\n            break;\n\n          case 'use':\n            style = parseStyle(node, style);\n            var usedNodeId = node.href.baseVal.substring(1);\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n\n            break;\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill);\n          }\n\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node: node,\n            style: style\n          };\n        }\n\n        if (traverseChildNodes) {\n          var nodes = node.childNodes;\n\n          for (var i = 0; i < nodes.length; i++) {\n            parseNode(nodes[i], style);\n          }\n        }\n\n        if (transform) {\n          transformStack.pop();\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        var path = new ShapePath();\n        var point = new Vector2();\n        var control = new Vector2();\n        var firstPoint = new Vector2();\n        var isFirstPoint = true;\n        var doSetFirstPoint = false;\n        var d = node.getAttribute('d'); // console.log( d );\n\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n        for (var i = 0, l = commands.length; i < l; i++) {\n          var command = commands[i];\n          var type = command.charAt(0);\n\n          var _data = command.substr(1).trim();\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n\n          var numbers = void 0;\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(_data);\n\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'H':\n              numbers = parseFloats(_data);\n\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n                point.x = numbers[_j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'V':\n              numbers = parseFloats(_data);\n\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n                point.y = numbers[_j2];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'L':\n              numbers = parseFloats(_data);\n\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n                point.x = numbers[_j3 + 0];\n                point.y = numbers[_j3 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'C':\n              numbers = parseFloats(_data);\n\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n                control.x = numbers[_j4 + 2];\n                control.y = numbers[_j4 + 3];\n                point.x = numbers[_j4 + 4];\n                point.y = numbers[_j4 + 5];\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'S':\n              numbers = parseFloats(_data);\n\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n                control.x = numbers[_j5 + 0];\n                control.y = numbers[_j5 + 1];\n                point.x = numbers[_j5 + 2];\n                point.y = numbers[_j5 + 3];\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'Q':\n              numbers = parseFloats(_data);\n\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n                control.x = numbers[_j6 + 0];\n                control.y = numbers[_j6 + 1];\n                point.x = numbers[_j6 + 2];\n                point.y = numbers[_j6 + 3];\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'T':\n              numbers = parseFloats(_data);\n\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n                var rx = getReflection(point.x, control.x);\n                var ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[_j7 + 0];\n                point.y = numbers[_j7 + 1];\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'A':\n              numbers = parseFloats(_data, [3, 4], 7);\n\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n                // skip command if start point == end point\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n                var start = point.clone();\n                point.x = numbers[_j8 + 5];\n                point.y = numbers[_j8 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'm':\n              numbers = parseFloats(_data);\n\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n                point.x += numbers[_j9 + 0];\n                point.y += numbers[_j9 + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (_j9 === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (_j9 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'h':\n              numbers = parseFloats(_data);\n\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n                point.x += numbers[_j10];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'v':\n              numbers = parseFloats(_data);\n\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n                point.y += numbers[_j11];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'l':\n              numbers = parseFloats(_data);\n\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n                point.x += numbers[_j12 + 0];\n                point.y += numbers[_j12 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'c':\n              numbers = parseFloats(_data);\n\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n                control.x = point.x + numbers[_j13 + 2];\n                control.y = point.y + numbers[_j13 + 3];\n                point.x += numbers[_j13 + 4];\n                point.y += numbers[_j13 + 5];\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 's':\n              numbers = parseFloats(_data);\n\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n                control.x = point.x + numbers[_j14 + 0];\n                control.y = point.y + numbers[_j14 + 1];\n                point.x += numbers[_j14 + 2];\n                point.y += numbers[_j14 + 3];\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'q':\n              numbers = parseFloats(_data);\n\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n                control.x = point.x + numbers[_j15 + 0];\n                control.y = point.y + numbers[_j15 + 1];\n                point.x += numbers[_j15 + 2];\n                point.y += numbers[_j15 + 3];\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 't':\n              numbers = parseFloats(_data);\n\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n                var _rx = getReflection(point.x, control.x);\n\n                var _ry = getReflection(point.y, control.y);\n\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n                control.x = _rx;\n                control.y = _ry;\n                point.x = point.x + numbers[_j16 + 0];\n                point.y = point.y + numbers[_j16 + 1];\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'a':\n              numbers = parseFloats(_data, [3, 4], 7);\n\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n                // skip command if no displacement\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n\n                var _start = point.clone();\n\n                point.x += numbers[_j17 + 5];\n                point.y += numbers[_j17 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true;\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n\n              break;\n\n            default:\n              console.warn(command);\n          } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n          doSetFirstPoint = false;\n        }\n\n        return path;\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\n          var stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n\n          for (var j = 0; j < selectorList.length; j++) {\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n          }\n        }\n      }\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y);\n          return;\n        }\n\n        x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n        rx = Math.abs(rx);\n        ry = Math.abs(ry); // Compute (x1', y1')\n\n        var dx2 = (start.x - end.x) / 2.0;\n        var dy2 = (start.y - end.y) / 2.0;\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n        var rxs = rx * rx;\n        var rys = ry * ry;\n        var x1ps = x1p * x1p;\n        var y1ps = y1p * y1p; // Ensure radii are large enough\n\n        var cr = x1ps / rxs + y1ps / rys;\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          var s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n\n        var dq = rxs * y1ps + rys * x1ps;\n        var pq = (rxs * rys - dq) / dq;\n        var q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        var cxp = q * rx * y1p / ry;\n        var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        var dot = ux * vx + uy * vy;\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n\n\n      function parseRectNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n        var w = parseFloatWithUnits(node.getAttribute('width'));\n        var h = parseFloatWithUnits(node.getAttribute('height'));\n        var path = new ShapePath();\n        path.moveTo(x + 2 * rx, y);\n        path.lineTo(x + w - 2 * rx, y);\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n        path.lineTo(x + w, y + h - 2 * ry);\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n        path.lineTo(x + 2 * rx, y + h);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n        }\n\n        path.lineTo(x, y + 2 * ry);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n        }\n\n        return path;\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute('points').replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute('points').replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n\n      function parseCircleNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n        var r = parseFloatWithUnits(node.getAttribute('r') || 0);\n        var subpath = new Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseEllipseNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n        var subpath = new Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseLineNode(node) {\n        var x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\n        var y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\n        var x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\n        var y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\n        var path = new ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      } //\n\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style); // clone style\n\n        var stylesheetStyles = {};\n\n        if (node.hasAttribute('class')) {\n          var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n\n          for (var i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined) {\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n              return v;\n            };\n          }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n\n        addStyle('fill', 'fill');\n        addStyle('fill-opacity', 'fillOpacity', clamp);\n        addStyle('opacity', 'opacity', clamp);\n        addStyle('stroke', 'stroke');\n        addStyle('stroke-opacity', 'strokeOpacity', clamp);\n        addStyle('stroke-width', 'strokeWidth', positive);\n        addStyle('stroke-linejoin', 'strokeLineJoin');\n        addStyle('stroke-linecap', 'strokeLineCap');\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n        addStyle('visibility', 'visibility');\n        return style;\n      } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n      function getReflection(a, b) {\n        return a - (b - a);\n      } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + typeof input);\n        } // Character groups\n\n\n        var RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        }; // States\n\n        var SEP = 0;\n        var INT = 1;\n        var FLOAT = 2;\n        var EXP = 3;\n        var state = SEP;\n        var seenComma = true;\n        var number = '',\n            exponent = '';\n        var result = [];\n\n        function throwSyntaxError(current, i, partial) {\n          var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n          error.partial = partial;\n          throw error;\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n\n          number = '';\n          exponent = '';\n        }\n\n        var current;\n        var length = input.length;\n\n        for (var i = 0; i < length; i++) {\n          current = input[i]; // check for flags\n\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          } // parse until next number\n\n\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            } // start new number\n\n\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            } // throw on double commas (e.g. \"1, , 2\")\n\n\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n\n              seenComma = true;\n            }\n          } // parse integer part\n\n\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          } // parse decimal part\n\n\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            } // throw on double decimal points (e.g. \"1..2\")\n\n\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result);\n            }\n          } // parse exponent part\n\n\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current;\n                continue;\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          } // end of number\n\n\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        } // add the last number found (if any)\n\n\n        newNumber();\n        return result;\n      } // Units\n\n\n      var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n      var unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n\n      function parseFloatWithUnits(string) {\n        var theUnit = 'px';\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (var i = 0, n = units.length; i < n; i++) {\n            var u = units[i];\n\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n\n        var scale = undefined;\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n          }\n        }\n\n        return scale * parseFloat(string);\n      } // Transforms\n\n\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n          return null;\n        }\n\n        var transform = parseNodeTransform(node);\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n\n      function parseNodeTransform(node) {\n        var transform = new Matrix3();\n        var currentTransform = tempTransform0;\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          var tx = parseFloatWithUnits(node.getAttribute('x'));\n          var ty = parseFloatWithUnits(node.getAttribute('y'));\n          transform.translate(tx, ty);\n        }\n\n        if (node.hasAttribute('transform')) {\n          var transformsTexts = node.getAttribute('transform').split(')');\n\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            var transformText = transformsTexts[tIndex].trim();\n            if (transformText === '') continue;\n            var openParPos = transformText.indexOf('(');\n            var closeParPos = transformText.length;\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              var transformType = transformText.substr(0, openParPos);\n              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n              currentTransform.identity();\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    var _tx = array[0];\n                    var _ty = _tx;\n\n                    if (array.length >= 2) {\n                      _ty = array[1];\n                    }\n\n                    currentTransform.translate(_tx, _ty);\n                  }\n\n                  break;\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    var angle = 0;\n                    var cx = 0;\n                    var cy = 0; // Angle\n\n                    angle = -array[0] * Math.PI / 180;\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1];\n                      cy = array[2];\n                    } // Rotate around center (cx, cy)\n\n\n                    tempTransform1.identity().translate(-cx, -cy);\n                    tempTransform2.identity().rotate(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.identity().translate(cx, cy);\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n\n                  break;\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    var scaleX = array[0];\n                    var scaleY = scaleX;\n\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n\n                    currentTransform.scale(scaleX, scaleY);\n                  }\n\n                  break;\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n\n                  break;\n              }\n            }\n\n            transform.premultiply(currentTransform);\n          }\n        }\n\n        return transform;\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n\n        var isRotated = isTransformRotated(m);\n        var subPaths = path.subPaths;\n\n        for (var i = 0, n = subPaths.length; i < n; i++) {\n          var subPath = subPaths[i];\n          var curves = subPath.curves;\n\n          for (var j = 0; j < curves.length; j++) {\n            var curve = curves[j];\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              if (isRotated) {\n                console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n              }\n\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              curve.xRadius *= getTransformScaleX(m);\n              curve.yRadius *= getTransformScaleY(m);\n            }\n          }\n        }\n      }\n\n      function isTransformRotated(m) {\n        return m.elements[1] !== 0 || m.elements[3] !== 0;\n      }\n\n      function getTransformScaleX(m) {\n        var te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n\n      function getTransformScaleY(m) {\n        var te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      } //\n\n\n      var paths = [];\n      var stylesheets = {};\n      var transformStack = [];\n      var tempTransform0 = new Matrix3();\n      var tempTransform1 = new Matrix3();\n      var tempTransform2 = new Matrix3();\n      var tempTransform3 = new Matrix3();\n      var tempV2 = new Vector2();\n      var tempV3 = new Vector3();\n      var currentTransform = new Matrix3();\n      var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4\n      });\n      var data = {\n        paths: paths,\n        xml: xml.documentElement\n      }; // console.log( paths );\n\n      return data;\n    }\n  }], [{\n    key: \"createShapes\",\n    value: function createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n      var BIGNUMBER = 999999999;\n      var IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      var classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        var x1 = a0.x;\n        var x2 = a1.x;\n        var x3 = b0.x;\n        var x4 = b1.x;\n        var y1 = a0.y;\n        var y2 = a1.y;\n        var y3 = b0.y;\n        var y4 = b1.y;\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        var t1 = nom1 / denom;\n        var t2 = nom2 / denom;\n\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (var i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1); //find position of this endpoints relatively to edge1\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x: x,\n                y: y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          return null;\n        } else {\n          //3. edges intersect\n          for (var _i = 0; _i < 2; _i++) {\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var _point = _i === 0 ? b0 : b1;\n\n              return {\n                x: _point.x,\n                y: _point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n\n          return {\n            x: _x,\n            y: _y,\n            t: t1\n          };\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        var ax = edgeEnd.x - edgeStart.x;\n        var ay = edgeEnd.y - edgeStart.y;\n        var bx = p.x - edgeStart.x;\n        var by = p.y - edgeStart.y;\n        var sa = ax * by - bx * ay;\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n\n        var t;\n\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n\n      function getIntersections(path1, path2) {\n        var intersectionsRaw = [];\n        var intersections = [];\n\n        for (var index = 1; index < path1.length; index++) {\n          var path1EdgeStart = path1[index - 1];\n          var path1EdgeEnd = path1[index];\n\n          var _loop = function _loop(index2) {\n            var path2EdgeStart = path2[index2 - 1];\n            var path2EdgeEnd = path2[index2];\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n\n            if (intersection !== null && intersectionsRaw.find(function (i) {\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\n            }) === undefined) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new Vector2(intersection.x, intersection.y));\n            }\n          };\n\n          for (var index2 = 1; index2 < path2.length; index2++) {\n            _loop(index2);\n          }\n        }\n\n        return intersections;\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        var center = new Vector2();\n        boundingBox.getCenter(center);\n        var allIntersections = [];\n        paths.forEach(function (path) {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            var intersections = getIntersections(scanline, path.points);\n            intersections.forEach(function (p) {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero';\n        }\n\n        var centerBoundingBox = new Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        var scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)];\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        var baseIntersections = [];\n        var otherIntersections = [];\n        scanlineIntersections.forEach(function (i) {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i);\n          } else {\n            otherIntersections.push(i);\n          }\n        });\n        var firstXOfPath = baseIntersections[0].point.x; // build up the path hierarchy\n\n        var stack = [];\n        var i = 0;\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n\n          i++;\n        }\n\n        stack.push(simplePath.identifier);\n\n        if (_fillRule === 'evenodd') {\n          var isHole = stack.length % 2 === 0 ? true : false;\n          var isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole: isHole,\n            for: isHoleFor\n          };\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          var _isHole = true;\n          var _isHoleFor = null;\n          var lastCWValue = null;\n\n          for (var _i2 = 0; _i2 < stack.length; _i2++) {\n            var _identifier = stack[_i2];\n\n            if (_isHole) {\n              lastCWValue = allPaths[_identifier].isCW;\n              _isHole = false;\n              _isHoleFor = _identifier;\n            } else if (lastCWValue !== allPaths[_identifier].isCW) {\n              lastCWValue = allPaths[_identifier].isCW;\n              _isHole = true;\n            }\n          }\n\n          return {\n            identifier: simplePath.identifier,\n            isHole: _isHole,\n            for: _isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      } // check for self intersecting paths\n      // TODO\n      // check intersecting paths\n      // TODO\n      // prepare paths for hole detection\n\n\n      var identifier = 0;\n      var scanlineMinX = BIGNUMBER;\n      var scanlineMaxX = -BIGNUMBER;\n      var simplePaths = shapePath.subPaths.map(function (p) {\n        var points = p.getPoints();\n        var maxY = -BIGNUMBER;\n        var minY = BIGNUMBER;\n        var maxX = -BIGNUMBER;\n        var minX = BIGNUMBER; //points.forEach(p => p.y *= -1);\n\n        for (var i = 0; i < points.length; i++) {\n          var _p = points[i];\n\n          if (_p.y > maxY) {\n            maxY = _p.y;\n          }\n\n          if (_p.y < minY) {\n            minY = _p.y;\n          }\n\n          if (_p.x > maxX) {\n            maxX = _p.x;\n          }\n\n          if (_p.x < minX) {\n            minX = _p.x;\n          }\n        } //\n\n\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n\n        return {\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: identifier++,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(function (sp) {\n        return sp.points.length > 0;\n      }); // check if path is solid or a hole\n\n      var isAHole = simplePaths.map(function (p) {\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule);\n      });\n      var shapesToReturn = [];\n      simplePaths.forEach(function (p) {\n        var amIAHole = isAHole[p.identifier];\n\n        if (!amIAHole.isHole) {\n          var shape = new Shape(p.points);\n          var holes = isAHole.filter(function (h) {\n            return h.isHole && h.for === p.identifier;\n          });\n          holes.forEach(function (h) {\n            var path = simplePaths[h.identifier];\n            shape.holes.push(new Path(path.points));\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n  }, {\n    key: \"getStrokeStyle\",\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n      width = width !== undefined ? width : 1;\n      color = color !== undefined ? color : '#000';\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n      lineCap = lineCap !== undefined ? lineCap : 'butt';\n      miterLimit = miterLimit !== undefined ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n  }, {\n    key: \"pointsToStroke\",\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some witdh around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n  }, {\n    key: \"pointsToStrokeWithBuffers\",\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n      var tempV2_1 = new Vector2();\n      var tempV2_2 = new Vector2();\n      var tempV2_3 = new Vector2();\n      var tempV2_4 = new Vector2();\n      var tempV2_5 = new Vector2();\n      var tempV2_6 = new Vector2();\n      var tempV2_7 = new Vector2();\n      var lastPointL = new Vector2();\n      var lastPointR = new Vector2();\n      var point0L = new Vector2();\n      var point0R = new Vector2();\n      var currentPointL = new Vector2();\n      var currentPointR = new Vector2();\n      var nextPointL = new Vector2();\n      var nextPointR = new Vector2();\n      var innerPoint = new Vector2();\n      var outerPoint = new Vector2();\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n      minDistance = minDistance !== undefined ? minDistance : 0.001;\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n      points = removeDuplicatedPoints(points);\n      var numPoints = points.length;\n      if (numPoints < 2) return 0;\n      var isClosed = points[0].equals(points[numPoints - 1]);\n      var currentPoint;\n      var previousPoint = points[0];\n      var nextPoint;\n      var strokeWidth2 = style.strokeWidth / 2;\n      var deltaU = 1 / (numPoints - 1);\n      var u0 = 0,\n          u1;\n      var innerSideModified;\n      var joinIsOnLeftSide;\n      var isMiter;\n      var initialJoinIsOnLeftSide = false;\n      var numVertices = 0;\n      var currentCoordinate = vertexOffset * 3;\n      var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]; // Get next point\n\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1];\n          } else {\n            nextPoint = undefined;\n          }\n        } else {\n          nextPoint = points[iPoint + 1];\n        } // Normal of previous segment in tempV2_1\n\n\n        var normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n          if (dot !== 0) {\n            // Compute inner and outer segment intersections\n            var miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            var miterLength2 = tempV2_5.length();\n            var segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            var segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n              makeSegmentTriangles();\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n\n              case 'round':\n                // Segment triangles\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n\n                break;\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    // Segment triangles\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    // Add extra miter join triangles\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n\n                  isMiter = true;\n                }\n\n                break;\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n            makeSegmentTriangles();\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n          makeSegmentTriangles();\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        } // Increment loop variables\n\n\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n        var lastOuter = outerPoint;\n        var lastInner = innerPoint;\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n\n      return numVertices; // -- End of algorithm\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n\n          currentCoordinate += 3;\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n\n        numVertices += 3;\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        var angle = Math.PI;\n        var dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 1);\n        addVertex(currentPointR, u1, 0);\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            // Path segments triangles\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n\n            break;\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              var vl = vertices.length; // Modify already existing vertices\n\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_3.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n\n            break;\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n        var dupPoints = false;\n\n        for (var i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n\n        if (!dupPoints) return points;\n        var newPoints = [];\n        newPoints.push(points[0]);\n\n        for (var _i3 = 1, _n = points.length - 1; _i3 < _n; _i3++) {\n          if (points[_i3].distanceTo(points[_i3 + 1]) >= minDistance) {\n            newPoints.push(points[_i3]);\n          }\n        }\n\n        newPoints.push(points[points.length - 1]);\n        return newPoints;\n      }\n    }\n  }]);\n\n  return SVGLoader;\n}(Loader);\n\nexport { SVGLoader };","map":{"version":3,"names":["Loader","FileLoader","Matrix3","Vector2","Vector3","ShapeUtils","Box2","Shape","Path","BufferGeometry","Float32BufferAttribute","ShapePath","SVGLoader","manager","defaultDPI","defaultUnit","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","usedNodeId","href","baseVal","substring","usedNode","viewportElement","getElementById","warn","fill","undefined","color","setStyle","transformPath","currentTransform","paths","push","userData","nodes","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","stylesheets","Object","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","SyntaxError","newNumber","Number","pow","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","i2","isHoleTo","simplePath","allPaths","scanlineMinX","scanlineMaxX","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","simplePaths","getPoints","maxY","minY","maxX","minX","isClockWise","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","holes","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"sources":["/home/cliffexpc63/my example/portfolio/node_modules/three-stdlib/loaders/SVGLoader.js"],"sourcesContent":["import { Loader, FileLoader, Matrix3, Vector2, Vector3, ShapeUtils, Box2, Shape, Path, BufferGeometry, Float32BufferAttribute, ShapePath } from 'three';\n\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Default dots per inch\n\n    this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n    this.defaultUnit = 'px';\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text) {\n    const scope = this;\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      const transform = getNodeTransform(node);\n      let traverseChildNodes = true;\n      let path = null;\n\n      switch (node.nodeName) {\n        case 'svg':\n          break;\n\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case 'defs':\n          traverseChildNodes = false;\n          break;\n\n        case 'use':\n          style = parseStyle(node, style);\n          const usedNodeId = node.href.baseVal.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n\n          break;\n\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n\n      if (traverseChildNodes) {\n        const nodes = node.childNodes;\n\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute('d'); // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data = command.substr(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        let numbers;\n\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'H':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'V':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'L':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'C':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'S':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Q':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'T':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'm':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'h':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'v':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'l':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'c':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 's':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'q':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 't':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      const dx2 = (start.x - end.x) / 2.0;\n      const dy2 = (start.y - end.y) / 2.0;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p; // Ensure radii are large enough\n\n      const cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n\n\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      const w = parseFloatWithUnits(node.getAttribute('width'));\n      const h = parseFloatWithUnits(node.getAttribute('height'));\n      const path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n\n      path.lineTo(x, y + 2 * ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      let stylesheetStyles = {};\n\n      if (node.hasAttribute('class')) {\n        const classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) {\n          adjustFunction = function copy(v) {\n            if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n            return v;\n          };\n        }\n\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      }; // States\n\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = '',\n          exponent = '';\n      const result = [];\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = '';\n        exponent = '';\n      }\n\n      let current;\n      const length = input.length;\n\n      for (let i = 0; i < length; i++) {\n        current = input[i]; // check for flags\n\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        } // parse until next number\n\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        } // parse integer part\n\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n\n      newNumber();\n      return result;\n    } // Units\n\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px';\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      let scale = undefined;\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    } // Transforms\n\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n\n      const transform = parseNodeTransform(node);\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform = tempTransform0;\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'));\n        const ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')');\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          const openParPos = transformText.indexOf('(');\n          const closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.substr(0, openParPos);\n            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                }\n\n                break;\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n\n                break;\n\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n\n      const isRotated = isTransformRotated(m);\n      const subPaths = path.subPaths;\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    const data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1); //find position of this endpoints relatively to edge1\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return {\n              x: x,\n              y: y,\n              t: classifyResult.t\n            };\n          }\n        }\n\n        return null;\n      } else {\n        //3. edges intersect\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return {\n          x: x,\n          y: y,\n          t: t1\n        };\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n\n      let t;\n\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n\n          if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === undefined) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n\n      return intersections;\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach(path => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach(p => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p\n            });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero';\n      }\n\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach(i => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i);\n        } else {\n          otherIntersections.push(i);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x; // build up the path hierarchy\n\n      const stack = [];\n      let i = 0;\n\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n\n        i++;\n      }\n\n      stack.push(simplePath.identifier);\n\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i];\n\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    } // check for self intersecting paths\n    // TODO\n    // check intersecting paths\n    // TODO\n    // prepare paths for hole detection\n\n\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map(p => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER; //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n\n        if (p.y > maxY) {\n          maxY = p.y;\n        }\n\n        if (p.y < minY) {\n          minY = p.y;\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n\n        if (p.x < minX) {\n          minX = p.x;\n        }\n      } //\n\n\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n\n      return {\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter(sp => sp.points.length > 0); // check if path is solid or a hole\n\n    const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));\n    const shapesToReturn = [];\n    simplePaths.forEach(p => {\n      const amIAHole = isAHole[p.identifier];\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape(p.points);\n        const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n        holes.forEach(h => {\n          const path = simplePaths[h.identifier];\n          shape.holes.push(new Path(path.points));\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n    width = width !== undefined ? width : 1;\n    color = color !== undefined ? color : '#000';\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n    lineCap = lineCap !== undefined ? lineCap : 'butt';\n    miterLimit = miterLimit !== undefined ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some witdh around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2) return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n        u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else {\n          nextPoint = undefined;\n        }\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n\n              break;\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      let dupPoints = false;\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n      const newPoints = [];\n      newPoints.push(points[0]);\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  }\n\n}\n\nexport { SVGLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}