{"ast":null,"code":"import _inherits from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three'; // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar conditionalLineVertShader =\n/* glsl */\n\"\\n\\tattribute vec3 control0;\\n\\tattribute vec3 control1;\\n\\tattribute vec3 direction;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_vertex>\\n\\t#include <fog_pars_vertex>\\n\\t#include <logdepthbuf_pars_vertex>\\n\\t#include <clipping_planes_pars_vertex>\\n\\tvoid main() {\\n\\t\\t#include <color_vertex>\\n\\n\\t\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t// Transform the line segment ends and control points into camera clip space\\n\\t\\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\\n\\t\\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\\n\\t\\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\\n\\n\\t\\tc0.xy /= c0.w;\\n\\t\\tc1.xy /= c1.w;\\n\\t\\tp0.xy /= p0.w;\\n\\t\\tp1.xy /= p1.w;\\n\\n\\t\\t// Get the direction of the segment and an orthogonal vector\\n\\t\\tvec2 dir = p1.xy - p0.xy;\\n\\t\\tvec2 norm = vec2( -dir.y, dir.x );\\n\\n\\t\\t// Get control point directions from the line\\n\\t\\tvec2 c0dir = c0.xy - p1.xy;\\n\\t\\tvec2 c1dir = c1.xy - p1.xy;\\n\\n\\t\\t// If the vectors to the controls points are pointed in different directions away\\n\\t\\t// from the line segment then the line should not be drawn.\\n\\t\\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\\n\\t\\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\\n\\t\\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\\n\\n\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t#include <clipping_planes_vertex>\\n\\t\\t#include <fog_vertex>\\n\\t}\\n\\t\";\nvar conditionalLineFragShader =\n/* glsl */\n\"\\n\\tuniform vec3 diffuse;\\n\\tuniform float opacity;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_fragment>\\n\\t#include <fog_pars_fragment>\\n\\t#include <logdepthbuf_pars_fragment>\\n\\t#include <clipping_planes_pars_fragment>\\n\\tvoid main() {\\n\\n\\t\\tif ( discardFlag > 0.5 ) discard;\\n\\n\\t\\t#include <clipping_planes_fragment>\\n\\t\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t#include <color_fragment>\\n\\t\\toutgoingLight = diffuseColor.rgb; // simple shader\\n\\t\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t\\t#include <tonemapping_fragment>\\n\\t\\t#include <encodings_fragment>\\n\\t\\t#include <fog_fragment>\\n\\t\\t#include <premultiplied_alpha_fragment>\\n\\t}\\n\\t\";\n\nvar _tempVec0 = new Vector3();\n\nvar _tempVec1 = new Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    var x = ~~(v.x * 1e2);\n    var y = ~~(v.y * 1e2);\n    var z = ~~(v.z * 1e2);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n\n  var hardEdges = new Set();\n  var halfEdgeList = {};\n  var fullHalfEdgeList = {};\n  var normals = []; // Save the list of hard edges by hash\n\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var v0 = ls.v0;\n    var v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (var _i = 0, _l = triangles.length; _i < _l; _i++) {\n    var tri = triangles[_i];\n\n    for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % 3;\n      var _v = tri[\"v\".concat(index)];\n      var _v2 = tri[\"v\".concat(next)];\n      var hash = hashEdge(_v, _v2); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    var halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    var _i2 = 0;\n    var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (_i2 < queue.length) {\n      // initialize all vertex normals in this triangle\n      var _tri = queue[_i2];\n      _i2++;\n      var faceNormal = _tri.faceNormal;\n\n      if (_tri.n0 === null) {\n        _tri.n0 = faceNormal.clone();\n        normals.push(_tri.n0);\n      }\n\n      if (_tri.n1 === null) {\n        _tri.n1 = faceNormal.clone();\n        normals.push(_tri.n1);\n      }\n\n      if (_tri.n2 === null) {\n        _tri.n2 = faceNormal.clone();\n        normals.push(_tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (var _i3 = 0, _l2 = 3; _i3 < _l2; _i3++) {\n        var _index = _i3;\n\n        var _next = (_i3 + 1) % 3;\n\n        var _v3 = _tri[\"v\".concat(_index)];\n\n        var _v4 = _tri[\"v\".concat(_next)]; // delete this triangle from the list so it won't be found again\n\n\n        var _hash = hashEdge(_v3, _v4);\n\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (var i3 = 0, l3 = 3; i3 < l3; i3++) {\n            var otherIndex = i3;\n            var otherNext = (i3 + 1) % 3;\n            var otherV0 = otherTri[\"v\".concat(otherIndex)];\n            var otherV1 = otherTri[\"v\".concat(otherNext)];\n            var otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[\"n\".concat(otherIndex)] === null) {\n                var norm = _tri[\"n\".concat(_next)];\n\n                otherTri[\"n\".concat(otherIndex)] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[\"n\".concat(otherNext)] === null) {\n                var _norm = _tri[\"n\".concat(_index)];\n\n                otherTri[\"n\".concat(otherNext)] = _norm;\n\n                _norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (var _i4 = 0, _l3 = normals.length; _i4 < _l3; _i4++) {\n    normals[_i4].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  }]);\n\n  return LineParser;\n}();\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  var positions = [];\n  var normals = [];\n  var materials = [];\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var v0 = elem.v0;\n    var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      var n0 = elem.n0 || elem.faceNormal;\n      var n1 = elem.n1 || elem.faceNormal;\n      var n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  var object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var os = elements[i];\n      var c0 = os.c0;\n      var c1 = os.c1;\n      var _v5 = os.v0;\n      var _v6 = os.v1;\n      var index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = _v6.x - _v5.x;\n      directionArray[index + 1] = _v6.y - _v5.y;\n      directionArray[index + 2] = _v6.z - _v5.z;\n      directionArray[index + 3] = _v6.x - _v5.x;\n      directionArray[index + 4] = _v6.y - _v5.y;\n      directionArray[index + 5] = _v6.z - _v5.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n\n  var _super = _createSuper(LDrawLoader);\n\n  function LDrawLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, LDrawLoader);\n\n    _this = _super.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    _this.parseScopesStack = null; // Array of THREE.Material\n\n    _this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    _this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    _this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    _this.setMaterials([_this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), _this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n\n    _this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    _this.smoothNormals = true;\n    return _this;\n  }\n\n  _createClass(LDrawLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"newParseScopeLevel\",\n    value: function newParseScopeLevel(materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (var i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new Matrix4(),\n        matrix: new Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    }\n  }, {\n    key: \"removeScopeLevel\",\n    value: function removeScopeLevel() {\n      this.parseScopesStack.pop();\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n\n      for (var i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    }\n  }, {\n    key: \"getParentParseScope\",\n    value: function getParentParseScope() {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getCurrentParseScope\",\n    value: function getCurrentParseScope() {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseColourMetaDirective\",\n    value: function parseColourMetaDirective(lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: UniformsUtils.merge([UniformsLib.fog, {\n            diffuse: {\n              value: new Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    } //\n\n  }, {\n    key: \"objectParse\",\n    value: function objectParse(text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n        var material = void 0;\n        var segment = void 0;\n        var inverted = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n            v1 = void 0,\n            v2 = void 0,\n            v3 = void 0,\n            faceNormal = void 0;\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            material = parseColourCode(lp, true);\n            segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            material = parseColourCode(lp, true);\n            segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            material = parseColourCode(lp);\n            inverted = currentParseScope.inverted;\n            ccw = bfcCCW !== inverted;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            _tempVec0.subVectors(v1, v0);\n\n            _tempVec1.subVectors(v2, v1);\n\n            faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            material = parseColourCode(lp);\n            inverted = currentParseScope.inverted;\n            ccw = bfcCCW !== inverted;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            _tempVec0.subVectors(v1, v0);\n\n            _tempVec1.subVectors(v2, v1);\n\n            faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }, {\n    key: \"processObject\",\n    value: function processObject(text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var _subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(_subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          var objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (var i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (var _i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n            var os = conditionalSegments[_i5];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (var _i6 = 0, _l5 = triangles.length; _i6 < _l5; _i6++) {\n            var tri = triangles[_i6];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n              _tempVec0.subVectors(tri.v1, tri.v0);\n\n              _tempVec1.subVectors(tri.v2, tri.v1);\n\n              tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  }]);\n\n  return LDrawLoader;\n}(Loader);\n\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","Loader","FileLoader","Matrix4","MeshStandardMaterial","Color","MeshPhongMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Group","BufferGeometry","Float32BufferAttribute","LineSegments","Mesh","BufferAttribute","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","conditionalLineVertShader","conditionalLineFragShader","_tempVec0","_tempVec1","smoothNormals","triangles","lineSegments","hashVertex","v","x","y","z","hashEdge","v0","v1","hardEdges","Set","halfEdgeList","fullHalfEdgeList","normals","i","l","length","ls","add","tri","i2","l2","index","next","hash","has","halfEdges","Object","keys","queue","faceNormal","n0","clone","push","n1","n2","reverseHash","otherTri","Math","abs","dot","i3","l3","otherIndex","otherNext","otherV0","otherV1","otherHash","norm","normalize","isPrimitiveType","type","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","charAt","pos0","pos1","seekNonSpace","substring","sortByMaterial","a","b","colourCode","createObject","elements","elementSize","isConditionalSegments","sort","positions","materials","bufferGeometry","prevMaterial","index0","numGroupVerts","iElem","nElem","elem","v2","material","addGroup","Infinity","setAttribute","object3d","isConditionalLine","controlArray0","Float32Array","controlArray1","directionArray","os","c0","c1","LDrawLoader","manager","parseScopesStack","subobjectCache","fileMap","setMaterials","parseColourMetaDirective","separateObjects","url","onLoad","onProgress","onError","scope","fileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","processObject","newParseScopeLevel","getCurrentParseScope","isFromParse","matLib","n","userData","code","topParseScope","newParseScope","lib","subobjects","numSubobjects","subobjectIndex","inverted","category","keywords","currentFileName","mainColourCode","mainEdgeColourCode","currentMatrix","matrix","conditionalSegments","startingConstructionStep","pop","startsWith","colour","lineParser","edgeColour","alpha","isTransparent","luminance","finishType","canHaveEnvMap","edgeMaterial","name","getToken","getLineNumberString","token","toUpperCase","getMaterial","parseInt","isNaN","max","min","setToEnd","color","roughness","envMapIntensity","metalness","specular","hsl","getHSL","h","s","setHSL","shininess","reflectivity","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","set","multiplyScalar","conditionalEdgeMaterial","vertexShader","fragmentShader","uniforms","merge","fog","diffuse","value","parentParseScope","getParentParseScope","currentParseScope","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","parseColourCode","forEdge","parseVector","lp","parseFloat","applyMatrix4","lineIndex","toLowerCase","isAtTheEnd","lineType","segment","ccw","doubleSided","v3","meta","isRoot","groupObject","determinant","addMaterial","console","warn","newKeywords","getRemainingString","forEach","keyword","trim","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","fileName","originalFileName","locationState","triedLowerCase","subVectors","crossVectors","model","stepNumber","traverse","c","isGroup","constructionStep","numConstructionSteps","onProcessed","subobject","parseScope","multiplyMatrices","copy","undefined","objectParse","finishedCount","onSubobjectFinish","finalizeObject","Promise","resolve","then","loadSubobject","objGroup","decompose","position","quaternion","scale","parentLineSegments","parentConditionalSegments","parentTriangles","removeScopeLevel","computeConstructionSteps","cached","subobjectGroup","onSubobjectLoaded","subobjectURL","newLocationState","lastIndexOf","err","onSubobjectError"],"sources":["/home/cliffexpc63/my example/portfolio/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst conditionalLineVertShader =\n/* glsl */\n`\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\nconst conditionalLineFragShader =\n/* glsl */\n`\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    const x = ~~(v.x * 1e2);\n    const y = ~~(v.y * 1e2);\n    const z = ~~(v.z * 1e2);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n\n  const hardEdges = new Set();\n  const halfEdgeList = {};\n  const fullHalfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const v0 = ls.v0;\n    const v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = triangles.length; i < l; i++) {\n    const tri = triangles[i];\n\n    for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % 3;\n      const v0 = tri[`v${index}`];\n      const v1 = tri[`v${next}`];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    const halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    let i = 0;\n    const queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (i < queue.length) {\n      // initialize all vertex normals in this triangle\n      const tri = queue[i];\n      i++;\n      const faceNormal = tri.faceNormal;\n\n      if (tri.n0 === null) {\n        tri.n0 = faceNormal.clone();\n        normals.push(tri.n0);\n      }\n\n      if (tri.n1 === null) {\n        tri.n1 = faceNormal.clone();\n        normals.push(tri.n1);\n      }\n\n      if (tri.n2 === null) {\n        tri.n2 = faceNormal.clone();\n        normals.push(tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % 3;\n        const v0 = tri[`v${index}`];\n        const v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n            const otherIndex = i3;\n            const otherNext = (i3 + 1) % 3;\n            const otherV0 = otherTri[`v${otherIndex}`];\n            const otherV1 = otherTri[`v${otherNext}`];\n            const otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[`n${otherIndex}`] === null) {\n                const norm = tri[`n${next}`];\n                otherTri[`n${otherIndex}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[`n${otherNext}`] === null) {\n                const norm = tri[`n${index}`];\n                otherTri[`n${otherNext}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  const positions = [];\n  const normals = [];\n  const materials = [];\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    const v0 = elem.v0;\n    const v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      const n0 = elem.n0 || elem.faceNormal;\n      const n1 = elem.n1 || elem.faceNormal;\n      const n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const c0 = os.c0;\n      const c1 = os.c1;\n      const v0 = os.v0;\n      const v1 = os.v1;\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (!this.fileMap) {\n      this.fileMap = {};\n    }\n\n    const scope = this;\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, function (text) {\n      scope.processObject(text, onLoad, null, url);\n    }, onProgress, onError);\n  }\n\n  parse(text, path, onLoad) {\n    // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n    this.processObject(text, onLoad, null, path);\n  }\n\n  setMaterials(materials) {\n    // Clears parse scopes stack, adds new scope with material library\n    this.parseScopesStack = [];\n    this.newParseScopeLevel(materials);\n    this.getCurrentParseScope().isFromParse = false;\n    this.materials = materials;\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  newParseScopeLevel(materials) {\n    // Adds a new scope level, assign materials to it and returns it\n    const matLib = {};\n\n    if (materials) {\n      for (let i = 0, n = materials.length; i < n; i++) {\n        const material = materials[i];\n        matLib[material.userData.code] = material;\n      }\n    }\n\n    const topParseScope = this.getCurrentParseScope();\n    const newParseScope = {\n      lib: matLib,\n      url: null,\n      // Subobjects\n      subobjects: null,\n      numSubobjects: 0,\n      subobjectIndex: 0,\n      inverted: false,\n      category: null,\n      keywords: null,\n      // Current subobject\n      currentFileName: null,\n      mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n      mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n      currentMatrix: new Matrix4(),\n      matrix: new Matrix4(),\n      // If false, it is a root material scope previous to parse\n      isFromParse: true,\n      triangles: null,\n      lineSegments: null,\n      conditionalSegments: null,\n      // If true, this object is the start of a construction step\n      startingConstructionStep: false\n    };\n    this.parseScopesStack.push(newParseScope);\n    return newParseScope;\n  }\n\n  removeScopeLevel() {\n    this.parseScopesStack.pop();\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.getCurrentParseScope().lib;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n    }\n\n    matLib[material.userData.code] = material;\n    return this;\n  }\n\n  getMaterial(colourCode) {\n    // Given a colour code search its material in the parse scopes stack\n    if (colourCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB colour)\n      const colour = colourCode.substring(3);\n      return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n    }\n\n    for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n      const material = this.parseScopesStack[i].lib[colourCode];\n\n      if (material) {\n        return material;\n      }\n    } // Material was not found\n\n\n    return null;\n  }\n\n  getParentParseScope() {\n    if (this.parseScopesStack.length > 1) {\n      return this.parseScopesStack[this.parseScopesStack.length - 2];\n    }\n\n    return null;\n  }\n\n  getCurrentParseScope() {\n    if (this.parseScopesStack.length > 0) {\n      return this.parseScopesStack[this.parseScopesStack.length - 1];\n    }\n\n    return null;\n  }\n\n  parseColourMetaDirective(lineParser) {\n    // Parses a colour definition and returns a THREE.Material or null if error\n    let code = null; // Triangle and line colours\n\n    let colour = 0xff00ff;\n    let edgeColour = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let canHaveEnvMap = true;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          colour = lineParser.getToken();\n\n          if (colour.startsWith('0x')) {\n            colour = '#' + colour.substring(2);\n          } else if (!colour.startsWith('#')) {\n            throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColour = lineParser.getToken();\n\n          if (edgeColour.startsWith('0x')) {\n            edgeColour = '#' + edgeColour.substring(2);\n          } else if (!edgeColour.startsWith('#')) {\n            // Try to see if edge colour is a colour code\n            edgeMaterial = this.getMaterial(edgeColour);\n\n            if (!edgeMaterial) {\n              throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.3,\n          envMapIntensity: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n        const specular = new Color(colour);\n        const hsl = specular.getHSL({\n          h: 0,\n          s: 0,\n          l: 0\n        });\n        hsl.h = (hsl.h + 0.5) % 1;\n        hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n        specular.setHSL(hsl.h, hsl.s, hsl.l);\n        material = new MeshPhongMaterial({\n          color: colour,\n          specular: specular,\n          shininess: 10,\n          reflectivity: 0.3\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.9,\n          metalness: 0\n        });\n        canHaveEnvMap = false;\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    material.userData.canHaveEnvMap = canHaveEnvMap;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColour,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n        vertexShader: conditionalLineVertShader,\n        fragmentShader: conditionalLineFragShader,\n        uniforms: UniformsUtils.merge([UniformsLib.fog, {\n          diffuse: {\n            value: new Color(edgeColour)\n          },\n          opacity: {\n            value: alpha\n          }\n        }]),\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    return material;\n  } //\n\n\n  objectParse(text) {\n    // Retrieve data from the parent parse scope\n    const parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n    const mainColourCode = parentParseScope.mainColourCode;\n    const mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n    const currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n    let triangles;\n    let lineSegments;\n    let conditionalSegments;\n    const subobjects = [];\n    let category = null;\n    let keywords = null;\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let type = '';\n    let startingConstructionStep = false;\n    const scope = this;\n\n    function parseColourCode(lineParser, forEdge) {\n      // Parses next colour code and returns a THREE.Material\n      let colourCode = lineParser.getToken();\n\n      if (!forEdge && colourCode === '16') {\n        colourCode = mainColourCode;\n      }\n\n      if (forEdge && colourCode === '24') {\n        colourCode = mainEdgeColourCode;\n      }\n\n      const material = scope.getMaterial(colourCode);\n\n      if (!material) {\n        throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n      }\n\n      return material;\n    }\n\n    function parseVector(lp) {\n      const v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n      if (!scope.separateObjects) {\n        v.applyMatrix4(currentParseScope.currentMatrix);\n      }\n\n      return v;\n    } // Parse all line commands\n\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let segment;\n      let inverted;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, faceNormal;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                currentParseScope.triangles = [];\n                currentParseScope.lineSegments = [];\n                currentParseScope.conditionalSegments = [];\n                currentParseScope.type = type;\n                const isRoot = !parentParseScope.isFromParse;\n\n                if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                  currentParseScope.groupObject = new Group();\n                  currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                } // If the scale of the object is negated then the triangle winding order\n                // needs to be flipped.\n\n\n                if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                  currentParseScope.inverted = !currentParseScope.inverted;\n                }\n\n                triangles = currentParseScope.triangles;\n                lineSegments = currentParseScope.lineSegments;\n                conditionalSegments = currentParseScope.conditionalSegments;\n                break;\n\n              case '!COLOUR':\n                material = this.parseColourMetaDirective(lp);\n\n                if (material) {\n                  this.addMaterial(material);\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          material = parseColourCode(lp);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (scope.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = scope.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            matrix: matrix,\n            fileName: fileName,\n            originalFileName: fileName,\n            locationState: FILE_LOCATION_AS_IS,\n            url: null,\n            triedLowerCase: false,\n            inverted: bfcInverted !== currentParseScope.inverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp)\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp),\n            c0: parseVector(lp),\n            c1: parseVector(lp)\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n          } else {\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n            v3 = parseVector(lp);\n          } else {\n            v3 = parseVector(lp);\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v2,\n            v2: v3,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v3,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n    }\n\n    currentParseScope.category = category;\n    currentParseScope.keywords = keywords;\n    currentParseScope.subobjects = subobjects;\n    currentParseScope.numSubobjects = subobjects.length;\n    currentParseScope.subobjectIndex = 0;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n  processObject(text, onProcessed, subobject, url) {\n    const scope = this;\n    const parseScope = scope.newParseScopeLevel();\n    parseScope.url = url;\n    const parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n    if (subobject) {\n      parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n      parseScope.matrix.copy(subobject.matrix);\n      parseScope.inverted = subobject.inverted;\n      parseScope.startingConstructionStep = subobject.startingConstructionStep;\n    } // Add to cache\n\n\n    let currentFileName = parentParseScope.currentFileName;\n\n    if (currentFileName !== null) {\n      currentFileName = parentParseScope.currentFileName.toLowerCase();\n    }\n\n    if (scope.subobjectCache[currentFileName] === undefined) {\n      scope.subobjectCache[currentFileName] = text;\n    } // Parse the object (returns a Group)\n\n\n    scope.objectParse(text);\n    let finishedCount = 0;\n    onSubobjectFinish();\n\n    function onSubobjectFinish() {\n      finishedCount++;\n\n      if (finishedCount === parseScope.subobjects.length + 1) {\n        finalizeObject();\n      } else {\n        // Once the previous subobject has finished we can start processing the next one in the list.\n        // The subobject processing shares scope in processing so it's important that they be loaded serially\n        // to avoid race conditions.\n        // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n        // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n        // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n        const subobject = parseScope.subobjects[parseScope.subobjectIndex];\n        Promise.resolve().then(function () {\n          loadSubobject(subobject);\n        });\n        parseScope.subobjectIndex++;\n      }\n    }\n\n    function finalizeObject() {\n      if (scope.smoothNormals && parseScope.type === 'Part') {\n        smoothNormals(parseScope.triangles, parseScope.lineSegments);\n      }\n\n      const isRoot = !parentParseScope.isFromParse;\n\n      if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n        const objGroup = parseScope.groupObject;\n\n        if (parseScope.triangles.length > 0) {\n          objGroup.add(createObject(parseScope.triangles, 3));\n        }\n\n        if (parseScope.lineSegments.length > 0) {\n          objGroup.add(createObject(parseScope.lineSegments, 2));\n        }\n\n        if (parseScope.conditionalSegments.length > 0) {\n          objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n        }\n\n        if (parentParseScope.groupObject) {\n          objGroup.name = parseScope.fileName;\n          objGroup.userData.category = parseScope.category;\n          objGroup.userData.keywords = parseScope.keywords;\n          parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n          parentParseScope.groupObject.add(objGroup);\n        }\n      } else {\n        const separateObjects = scope.separateObjects;\n        const parentLineSegments = parentParseScope.lineSegments;\n        const parentConditionalSegments = parentParseScope.conditionalSegments;\n        const parentTriangles = parentParseScope.triangles;\n        const lineSegments = parseScope.lineSegments;\n        const conditionalSegments = parseScope.conditionalSegments;\n        const triangles = parseScope.triangles;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n\n          if (separateObjects) {\n            ls.v0.applyMatrix4(parseScope.matrix);\n            ls.v1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n\n          if (separateObjects) {\n            os.v0.applyMatrix4(parseScope.matrix);\n            os.v1.applyMatrix4(parseScope.matrix);\n            os.c0.applyMatrix4(parseScope.matrix);\n            os.c1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          const tri = triangles[i];\n\n          if (separateObjects) {\n            tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n            tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n            tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n            _tempVec0.subVectors(tri.v1, tri.v0);\n\n            _tempVec1.subVectors(tri.v2, tri.v1);\n\n            tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n          }\n\n          parentTriangles.push(tri);\n        }\n      }\n\n      scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n      if (!parentParseScope.isFromParse) {\n        scope.computeConstructionSteps(parseScope.groupObject);\n      }\n\n      if (onProcessed) {\n        onProcessed(parseScope.groupObject);\n      }\n    }\n\n    function loadSubobject(subobject) {\n      parseScope.mainColourCode = subobject.material.userData.code;\n      parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n      parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n      const cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n      if (cached) {\n        scope.processObject(cached, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n        return;\n      } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n      // Update also subobject.locationState for the next try if this load fails.\n\n\n      let subobjectURL = subobject.fileName;\n      let newLocationState = FILE_LOCATION_NOT_FOUND;\n\n      switch (subobject.locationState) {\n        case FILE_LOCATION_AS_IS:\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (subobject.triedLowerCase) {\n            // Try absolute path\n            newLocationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            subobject.fileName = subobject.fileName.toLowerCase();\n            subobjectURL = subobject.fileName;\n            subobject.triedLowerCase = true;\n            newLocationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n\n        case FILE_LOCATION_NOT_FOUND:\n          // All location possibilities have been tried, give up loading this object\n          console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n          return;\n      }\n\n      subobject.locationState = newLocationState;\n      subobject.url = subobjectURL; // Load the subobject\n      // Use another file loader here so we can keep track of the subobject information\n      // and use it when processing the next model.\n\n      const fileLoader = new FileLoader(scope.manager);\n      fileLoader.setPath(scope.path);\n      fileLoader.setRequestHeader(scope.requestHeader);\n      fileLoader.setWithCredentials(scope.withCredentials);\n      fileLoader.load(subobjectURL, function (text) {\n        scope.processObject(text, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n      }, undefined, function (err) {\n        onSubobjectError(err, subobject);\n      }, subobject);\n    }\n\n    function onSubobjectLoaded(subobjectGroup, subobject) {\n      if (subobjectGroup === null) {\n        // Try to reload\n        loadSubobject(subobject);\n        return;\n      }\n\n      scope.fileMap[subobject.originalFileName] = subobject.url;\n    }\n\n    function onSubobjectError(err, subobject) {\n      // Retry download from a different default possible location\n      loadSubobject(subobject);\n    }\n  }\n\n}\n\nexport { LDrawLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}