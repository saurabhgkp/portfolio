{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\nfunction PhongNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.specular = new ColorNode(0x111111);\n  this.shininess = new FloatNode(30);\n}\nPhongNode.prototype = Object.create(Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif',\n    //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED',\n    // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [\n    // prevent undeclared normal\n    '#include <normal_fragment_begin>',\n    // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push(\n    // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n    if (environment) {\n      output.push(environment.code);\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n  return code;\n};\nPhongNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { PhongNode };","map":null,"metadata":{},"sourceType":"module"}