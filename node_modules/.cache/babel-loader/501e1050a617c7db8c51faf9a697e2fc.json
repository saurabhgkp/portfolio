{"ast":null,"code":"import _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Triangle, Vector3, Line3, Sphere } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\nexport var SeparatingAxisTriangle = /*#__PURE__*/function (_Triangle) {\n  _inherits(SeparatingAxisTriangle, _Triangle);\n  function SeparatingAxisTriangle() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, SeparatingAxisTriangle);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SeparatingAxisTriangle)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.isSeparatingAxisTriangle = true;\n    _this.satAxes = new Array(4).fill().map(function () {\n      return new Vector3();\n    });\n    _this.satBounds = new Array(4).fill().map(function () {\n      return new SeparatingAxisBounds();\n    });\n    _this.points = [_this.a, _this.b, _this.c];\n    _this.sphere = new Sphere();\n    _this.needsUpdate = false;\n    return _this;\n  }\n  _createClass(SeparatingAxisTriangle, [{\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return sphereIntersectTriangle(sphere, this);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var a = this.a;\n      var b = this.b;\n      var c = this.c;\n      var points = this.points;\n      var satAxes = this.satAxes;\n      var satBounds = this.satBounds;\n      var axis0 = satAxes[0];\n      var sab0 = satBounds[0];\n      this.getNormal(axis0);\n      sab0.setFromPoints(axis0, points);\n      var axis1 = satAxes[1];\n      var sab1 = satBounds[1];\n      axis1.subVectors(a, b);\n      sab1.setFromPoints(axis1, points);\n      var axis2 = satAxes[2];\n      var sab2 = satBounds[2];\n      axis2.subVectors(b, c);\n      sab2.setFromPoints(axis2, points);\n      var axis3 = satAxes[3];\n      var sab3 = satBounds[3];\n      axis3.subVectors(c, a);\n      sab3.setFromPoints(axis3, points);\n      this.sphere.setFromPoints(this.points);\n      this.needsUpdate = false;\n    }\n  }]);\n  return SeparatingAxisTriangle;\n}(Triangle);\nSeparatingAxisTriangle.prototype.closestPointToSegment = function () {\n  var point1 = new Vector3();\n  var point2 = new Vector3();\n  var edge = new Line3();\n  return function distanceToSegment(segment) {\n    var target1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var target2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var start = segment.start,\n      end = segment.end;\n    var points = this.points;\n    var distSq;\n    var closestDistanceSq = Infinity;\n\n    // check the triangle edges\n    for (var i = 0; i < 3; i++) {\n      var nexti = (i + 1) % 3;\n      edge.start.copy(points[i]);\n      edge.end.copy(points[nexti]);\n      closestPointsSegmentToSegment(edge, segment, point1, point2);\n      distSq = point1.distanceToSquared(point2);\n      if (distSq < closestDistanceSq) {\n        closestDistanceSq = distSq;\n        if (target1) target1.copy(point1);\n        if (target2) target2.copy(point2);\n      }\n    }\n\n    // check end points\n    this.closestPointToPoint(start, point1);\n    distSq = start.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(start);\n    }\n    this.closestPointToPoint(end, point1);\n    distSq = end.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(end);\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\nSeparatingAxisTriangle.prototype.intersectsTriangle = function () {\n  var saTri2 = new SeparatingAxisTriangle();\n  var arr1 = new Array(3);\n  var arr2 = new Array(3);\n  var cachedSatBounds = new SeparatingAxisBounds();\n  var cachedSatBounds2 = new SeparatingAxisBounds();\n  var cachedAxis = new Vector3();\n  return function intersectsTriangle(other) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (!other.isSeparatingAxisTriangle) {\n      saTri2.copy(other);\n      saTri2.update();\n      other = saTri2;\n    } else if (other.needsUpdate) {\n      other.update();\n    }\n    var satBounds1 = this.satBounds;\n    var satAxes1 = this.satAxes;\n    arr2[0] = other.a;\n    arr2[1] = other.b;\n    arr2[2] = other.c;\n    for (var i = 0; i < 4; i++) {\n      var sb = satBounds1[i];\n      var sa = satAxes1[i];\n      cachedSatBounds.setFromPoints(sa, arr2);\n      if (sb.isSeparated(cachedSatBounds)) return false;\n    }\n    var satBounds2 = other.satBounds;\n    var satAxes2 = other.satAxes;\n    arr1[0] = this.a;\n    arr1[1] = this.b;\n    arr1[2] = this.c;\n    for (var _i = 0; _i < 4; _i++) {\n      var _sb = satBounds2[_i];\n      var _sa = satAxes2[_i];\n      cachedSatBounds.setFromPoints(_sa, arr1);\n      if (_sb.isSeparated(cachedSatBounds)) return false;\n    }\n\n    // check crossed axes\n    for (var _i2 = 0; _i2 < 4; _i2++) {\n      var sa1 = satAxes1[_i2];\n      for (var i2 = 0; i2 < 4; i2++) {\n        var sa2 = satAxes2[i2];\n        cachedAxis.crossVectors(sa1, sa2);\n        cachedSatBounds.setFromPoints(cachedAxis, arr1);\n        cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n      }\n    }\n    return true;\n  };\n}();\nSeparatingAxisTriangle.prototype.distanceToPoint = function () {\n  var target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\nSeparatingAxisTriangle.prototype.distanceToTriangle = function () {\n  var point = new Vector3();\n  var point2 = new Vector3();\n  var cornerFields = ['a', 'b', 'c'];\n  var line1 = new Line3();\n  var line2 = new Line3();\n  return function distanceToTriangle(other) {\n    var target1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var target2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (this.intersectsTriangle(other)) {\n      // TODO: This will not result in a point that lies on\n      // the intersection line of the triangles\n      if (target1 || target2) {\n        this.getMidpoint(point);\n        other.closestPointToPoint(point, point2);\n        this.closestPointToPoint(point2, point);\n        if (target1) target1.copy(point);\n        if (target2) target2.copy(point2);\n      }\n      return 0;\n    }\n    var closestDistanceSq = Infinity;\n\n    // check all point distances\n    for (var i = 0; i < 3; i++) {\n      var dist = void 0;\n      var field = cornerFields[i];\n      var otherVec = other[field];\n      this.closestPointToPoint(otherVec, point);\n      dist = otherVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(point);\n        if (target2) target2.copy(otherVec);\n      }\n      var thisVec = this[field];\n      other.closestPointToPoint(thisVec, point);\n      dist = thisVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(thisVec);\n        if (target2) target2.copy(point);\n      }\n    }\n    for (var _i3 = 0; _i3 < 3; _i3++) {\n      var f11 = cornerFields[_i3];\n      var f12 = cornerFields[(_i3 + 1) % 3];\n      line1.set(this[f11], this[f12]);\n      for (var i2 = 0; i2 < 3; i2++) {\n        var f21 = cornerFields[i2];\n        var f22 = cornerFields[(i2 + 1) % 3];\n        line2.set(other[f21], other[f22]);\n        closestPointsSegmentToSegment(line1, line2, point, point2);\n        var _dist = point.distanceToSquared(point2);\n        if (_dist < closestDistanceSq) {\n          closestDistanceSq = _dist;\n          if (target1) target1.copy(point);\n          if (target2) target2.copy(point2);\n        }\n      }\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}