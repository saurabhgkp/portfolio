{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.charCodeToOptimizedIndex = exports.minOptimizationVal = exports.buildLineBreakIssueMessage = exports.LineTerminatorOptimizedTester = exports.isShortPattern = exports.isCustomPattern = exports.cloneEmptyGroups = exports.performWarningRuntimeChecks = exports.performRuntimeChecks = exports.addStickyFlag = exports.addStartOfInput = exports.findUnreachablePatterns = exports.findModesThatDoNotExist = exports.findInvalidGroupType = exports.findDuplicatePatterns = exports.findUnsupportedFlags = exports.findStartOfInputAnchor = exports.findEmptyMatchRegExps = exports.findEndOfInputAnchor = exports.findInvalidPatterns = exports.findMissingPatterns = exports.validatePatterns = exports.analyzeTokenTypes = exports.enableSticky = exports.disableSticky = exports.SUPPORT_STICKY = exports.MODES = exports.DEFAULT_MODE = void 0;\n\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\n\nvar lexer_public_1 = require(\"./lexer_public\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar reg_exp_1 = require(\"./reg_exp\");\n\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\n\nvar PATTERN = \"PATTERN\";\nexports.DEFAULT_MODE = \"defaultMode\";\nexports.MODES = \"modes\";\nexports.SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\n\nfunction disableSticky() {\n  exports.SUPPORT_STICKY = false;\n}\n\nexports.disableSticky = disableSticky;\n\nfunction enableSticky() {\n  exports.SUPPORT_STICKY = true;\n}\n\nexports.enableSticky = enableSticky;\n\nfunction analyzeTokenTypes(tokenTypes, options) {\n  options = utils_1.defaults(options, {\n    useSticky: exports.SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function (msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = utils_1.reject(tokenTypes, function (currType) {\n      return currType[PATTERN] === lexer_public_1.Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = utils_1.map(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n\n      if (utils_1.isRegExp(currPattern)) {\n        var regExpSource = currPattern.source;\n\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !utils_1.contains([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (utils_1.isFunction(currPattern)) {\n        hasCustom = true; // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n\n        return {\n          exec: currPattern\n        };\n      } else if (utils_1.has(currPattern, \"exec\")) {\n        hasCustom = true; // ICustomPattern\n\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdx;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = utils_1.map(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = utils_1.map(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n\n      if (groupName === lexer_public_1.Lexer.SKIPPED) {\n        return undefined;\n      } else if (utils_1.isString(groupName)) {\n        return groupName;\n      } else if (utils_1.isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdx = utils_1.map(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n\n      if (longerAltType) {\n        var longerAltIdx = utils_1.indexOf(onlyRelevantTypes, longerAltType);\n        return longerAltIdx;\n      }\n    });\n    patternIdxToPushMode = utils_1.map(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = utils_1.map(onlyRelevantTypes, function (clazz) {\n      return utils_1.has(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = utils_1.map(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = utils_1.map(onlyRelevantTypes, function (tokType) {\n        if (utils_1.has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS;\n        } else {\n          if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n            return reg_exp_1.canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          }\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = utils_1.map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = utils_1.map(allTransformedPatterns, isShortPattern);\n    emptyGroups = utils_1.reduce(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n\n      if (utils_1.isString(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n\n      return acc;\n    }, {});\n    patternIdxToConfig = utils_1.map(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = utils_1.reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (utils_1.isArray(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          utils_1.forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode); // Avoid adding the config multiple times\n\n            /* istanbul ignore else */\n            // - Difficult to check this scenario effects as it is only a performance\n            //   optimization that does not change correctness\n\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (utils_1.isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n\n            if (options.ensureOptimizations) {\n              utils_1.PRINT_ERROR(\"\" + reg_exp_1.failedOptimizationPrefixMsg + (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = reg_exp_1.getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n\n            if (utils_1.isEmpty(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n\n            utils_1.forEach(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            utils_1.PRINT_ERROR(\"\" + reg_exp_1.failedOptimizationPrefixMsg + (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n\n          canBeOptimized = false;\n        }\n\n        return result;\n      }, []);\n    });\n  }\n\n  tracer(\"ArrayPacking\", function () {\n    charCodeToPatternIdxToConfig = utils_1.packArray(charCodeToPatternIdxToConfig);\n  });\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\n\nexports.analyzeTokenTypes = analyzeTokenTypes;\n\nfunction validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\n\nexports.validatePatterns = validatePatterns;\n\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = utils_1.filter(tokenTypes, function (currTokType) {\n    return utils_1.isRegExp(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\n\nfunction findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = utils_1.filter(tokenTypes, function (currType) {\n    return !utils_1.has(currType, PATTERN);\n  });\n  var errors = utils_1.map(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = utils_1.difference(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\n\nexports.findMissingPatterns = findMissingPatterns;\n\nfunction findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = utils_1.filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !utils_1.isRegExp(pattern) && !utils_1.isFunction(pattern) && !utils_1.has(pattern, \"exec\") && !utils_1.isString(pattern);\n  });\n  var errors = utils_1.map(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = utils_1.difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\n\nexports.findInvalidPatterns = findInvalidPatterns;\nvar end_of_input = /[^\\\\][\\$]/;\n\nfunction findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder =\n  /** @class */\n  function (_super) {\n    __extends(EndAnchorFinder, _super);\n\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n\n    return EndAnchorFinder;\n  }(regexp_to_ast_1.BaseRegExpVisitor);\n\n  var invalidRegex = utils_1.filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = reg_exp_parser_1.getRegExpAst(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = utils_1.map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n\nexports.findEndOfInputAnchor = findEndOfInputAnchor;\n\nfunction findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = utils_1.filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern.test(\"\");\n  });\n  var errors = utils_1.map(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n\nexports.findEmptyMatchRegExps = findEmptyMatchRegExps;\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\n\nfunction findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder =\n  /** @class */\n  function (_super) {\n    __extends(StartAnchorFinder, _super);\n\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n\n    return StartAnchorFinder;\n  }(regexp_to_ast_1.BaseRegExpVisitor);\n\n  var invalidRegex = utils_1.filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = reg_exp_parser_1.getRegExpAst(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = utils_1.map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n\nexports.findStartOfInputAnchor = findStartOfInputAnchor;\n\nfunction findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = utils_1.filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = utils_1.map(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n\nexports.findUnsupportedFlags = findUnsupportedFlags; // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n\nfunction findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = utils_1.map(tokenTypes, function (outerType) {\n    return utils_1.reduce(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !utils_1.contains(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n\n      return result;\n    }, []);\n  });\n  identicalPatterns = utils_1.compact(identicalPatterns);\n  var duplicatePatterns = utils_1.filter(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = utils_1.map(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = utils_1.map(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = utils_1.first(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" + (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n      type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\n\nexports.findDuplicatePatterns = findDuplicatePatterns;\n\nfunction findInvalidGroupType(tokenTypes) {\n  var invalidTypes = utils_1.filter(tokenTypes, function (clazz) {\n    if (!utils_1.has(clazz, \"GROUP\")) {\n      return false;\n    }\n\n    var group = clazz.GROUP;\n    return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !utils_1.isString(group);\n  });\n  var errors = utils_1.map(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n\nexports.findInvalidGroupType = findInvalidGroupType;\n\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = utils_1.filter(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !utils_1.contains(validModes, clazz.PUSH_MODE);\n  });\n  var errors = utils_1.map(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" + \"which does not exist\";\n    return {\n      message: msg,\n      type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\n\nexports.findModesThatDoNotExist = findModesThatDoNotExist;\n\nfunction findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = utils_1.reduce(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n\n    if (pattern === lexer_public_1.Lexer.NA) {\n      return result;\n    } // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n\n\n    if (utils_1.isString(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if (utils_1.isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n\n    return result;\n  }, []);\n  utils_1.forEach(tokenTypes, function (tokType, testIdx) {\n    utils_1.forEach(canBeTested, function (_a) {\n      var str = _a.str,\n          idx = _a.idx,\n          tokenType = _a.tokenType;\n\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" + (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") + \"in the lexer's definition.\\n\" + \"See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.findUnreachablePatterns = findUnreachablePatterns;\n\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if (utils_1.isRegExp(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (utils_1.isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (utils_1.has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return utils_1.find(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\n\nfunction addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\n\nexports.addStartOfInput = addStartOfInput;\n\nfunction addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"\" + pattern.source, flags);\n}\n\nexports.addStickyFlag = addStickyFlag;\n\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = []; // some run time checks to help the end users.\n\n  if (!utils_1.has(lexerDefinition, exports.DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + exports.DEFAULT_MODE + \"> property in its definition\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n\n  if (!utils_1.has(lexerDefinition, exports.MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + exports.MODES + \"> property in its definition\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n\n  if (utils_1.has(lexerDefinition, exports.MODES) && utils_1.has(lexerDefinition, exports.DEFAULT_MODE) && !utils_1.has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \" + exports.DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" + \"which does not exist\\n\",\n      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n\n  if (utils_1.has(lexerDefinition, exports.MODES)) {\n    utils_1.forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n      utils_1.forEach(currModeValue, function (currTokType, currIdx) {\n        if (utils_1.isUndefined(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n            type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        }\n      });\n    });\n  }\n\n  return errors;\n}\n\nexports.performRuntimeChecks = performRuntimeChecks;\n\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = utils_1.compact(utils_1.flatten(utils_1.mapValues(lexerDefinition.modes, function (tokTypes) {\n    return tokTypes;\n  })));\n  var concreteTokenTypes = utils_1.reject(allTokenTypes, function (currType) {\n    return currType[PATTERN] === lexer_public_1.Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n\n  if (trackLines) {\n    utils_1.forEach(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (utils_1.has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (reg_exp_1.canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n\n  return warnings;\n}\n\nexports.performWarningRuntimeChecks = performWarningRuntimeChecks;\n\nfunction cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = utils_1.keys(emptyGroups);\n  utils_1.forEach(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n\n    if (utils_1.isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\n\nexports.cloneEmptyGroups = cloneEmptyGroups; // TODO: refactor to avoid duplication\n\nfunction isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n\n  if (utils_1.isRegExp(pattern)) {\n    return false;\n  } else if (utils_1.isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (utils_1.has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (utils_1.isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.isCustomPattern = isCustomPattern;\n\nfunction isShortPattern(pattern) {\n  if (utils_1.isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n\nexports.isShortPattern = isShortPattern;\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\n\nexports.LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    var len = text.length;\n\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  lastIndex: 0\n};\n\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (utils_1.has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (utils_1.isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        reg_exp_1.canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n\n      return false;\n    } else if (utils_1.isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n\nfunction buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + (\"\\t Root cause: \" + details.errMsg + \".\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.buildLineBreakIssueMessage = buildLineBreakIssueMessage;\n\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = utils_1.map(charsOrCodes, function (numOrString) {\n    if (utils_1.isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\n\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n\nexports.minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\n\nvar charCodeToOptimizedIdxMap = [];\n\nfunction charCodeToOptimizedIndex(charCode) {\n  return charCode < exports.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n\nexports.charCodeToOptimizedIndex = charCodeToOptimizedIndex;\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\n\nfunction initCharCodeToOptimizedIndexMap() {\n  if (utils_1.isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n\n    for (var i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n      /* tslint:enable */\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["PATTERN","exports","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","utils_1","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","lexer_public_1","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","ignoreCase","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdx","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdx","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","reg_exp_1","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","toString","optimizedCodes","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","concat","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","type","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","__extends","_this","EndAnchorFinder","node","found","regexp_to_ast_1","invalidRegex","regexpAst","reg_exp_parser_1","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","indexOf","flags","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","tokTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","map","key","value","charCodeToOptimizedIdxMap","Array"],"sourceRoot":"","sources":["../../../src/scan/lexer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}