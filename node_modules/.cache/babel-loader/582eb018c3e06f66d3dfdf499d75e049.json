{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\n\nvar utils = require(\"@chevrotain/utils\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar gast_1 = require(\"./gast/gast\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if (utils_1.every(leftRecursionErrors, utils_1.isEmpty)) {\n    emptyAltErrors = utils_1.map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = utils_1.map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = utils_1.map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = utils_1.map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = gast_1.getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return gast_1.getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_public_1.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_public_1.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = utils_1.reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_public_1.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_public_1.Alternative || firstProd instanceof gast_public_1.Option || firstProd instanceof gast_public_1.RepetitionMandatory || firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator || firstProd instanceof gast_public_1.RepetitionWithSeparator || firstProd instanceof gast_public_1.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_public_1.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_public_1.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = gast_1.isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = interpreter_1.nextPossibleTokensAfter([currAlternative], [], null, 1);\n\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = utils_1.reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = lookahead_1.getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nvar RepetionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetionCollector, _super);\n\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetionCollector;\n}(gast_visitor_public_1.GAstVisitor);\n\nexports.RepetionCollector = RepetionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n\n    return errors;\n  }, []);\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  utils_1.forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    utils_1.forEach(allRuleProductions, function (currProd) {\n      var prodType = lookahead_1.getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = lookahead_1.getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if (utils_1.isEmpty(utils_1.flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = utils_1.reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    utils_1.forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      utils_1.forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && lookahead_1.containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !lookahead_1.containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = utils_1.map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = []; // flatten\n\n  var pathsAndIndices = utils_1.reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = utils_1.map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  utils_1.forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = utils_1.findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = utils_1.map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = utils_1.map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  utils_1.forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if (utils_1.contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","utils","map","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","utils_1","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","flatten","concat","exports","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","groupBy","identifyProductionForDuplicates","duplicates","pick","currGroup","length","errors","values","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","gast_1","defError","message","type","parser_1","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_public_1","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_visitor_public_1","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","contains","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","isEmpty","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","reduce","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","interpreter_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","lookahead_1","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sourceRoot":"","sources":["../../../../src/parse/grammar/checks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}