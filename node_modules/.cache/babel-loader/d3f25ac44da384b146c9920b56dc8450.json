{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nfunction SpriteNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.spherical = true;\n}\nSpriteNode.prototype = Object.create(Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;',\n    // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n    output.push(\n    // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n    if (this.spherical) {\n      output.push(\n      // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n    output.push(\n    // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n      alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n      color = this.color.flow(builder, 'c', {\n        slot: 'color'\n      }),\n      output = [];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n  return output.join('\\n');\n};\nSpriteNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { SpriteNode };","map":null,"metadata":{},"sourceType":"module"}