{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ExpressionNode } from '../../core/ExpressionNode.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\nimport { SpecularMIPLevelNode } from '../../utils/SpecularMIPLevelNode.js';\nfunction StandardNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xffffff);\n  this.roughness = new FloatNode(1);\n  this.metalness = new FloatNode(0);\n}\nStandardNode.prototype = Object.create(Node.prototype);\nStandardNode.prototype.constructor = StandardNode;\nStandardNode.prototype.nodeType = 'Standard';\nStandardNode.prototype.build = function (builder) {\n  var code;\n  builder.define('STANDARD');\n  var useClearcoat = this.clearcoat || this.clearcoatRoughness || this.clearCoatNormal;\n  if (useClearcoat) {\n    builder.define('CLEARCOAT');\n  }\n  builder.requires.lights = true;\n  builder.extensions.derivatives = true;\n  builder.extensions.shaderTextureLOD = true;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    if (UniformsLib.LTC_1) {\n      // add ltc data textures to material uniforms\n      builder.uniforms.ltc_1 = {\n        value: undefined\n      };\n      builder.uniforms.ltc_2 = {\n        value: undefined\n      };\n    }\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif',\n    //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED',\n    // Normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\n    code = output.join('\\n');\n  } else {\n    var specularRoughness = new ExpressionNode('material.specularRoughness', 'f');\n    var clearcoatRoughness = new ExpressionNode('material.clearcoatRoughness', 'f');\n    var contextEnvironment = {\n      roughness: specularRoughness,\n      bias: new SpecularMIPLevelNode(specularRoughness),\n      viewNormal: new ExpressionNode('normal', 'v3'),\n      worldNormal: new ExpressionNode('inverseTransformDirection( geometry.normal, viewMatrix )', 'v3'),\n      gamma: true\n    };\n    var contextGammaOnly = {\n      gamma: true\n    };\n    var contextClearcoatEnvironment = {\n      roughness: clearcoatRoughness,\n      bias: new SpecularMIPLevelNode(clearcoatRoughness),\n      viewNormal: new ExpressionNode('clearcoatNormal', 'v3'),\n      worldNormal: new ExpressionNode('inverseTransformDirection( geometry.clearcoatNormal, viewMatrix )', 'v3'),\n      gamma: true\n    }; // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color',\n      context: contextGammaOnly\n    });\n    this.roughness.analyze(builder);\n    this.metalness.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.clearcoat) this.clearcoat.analyze(builder);\n    if (this.clearcoatRoughness) this.clearcoatRoughness.analyze(builder);\n    if (this.clearcoatNormal) this.clearcoatNormal.analyze(builder);\n    if (this.reflectivity) this.reflectivity.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) {\n      // isolate environment from others inputs ( see TextureNode, CubeTextureNode )\n      // environment.analyze will detect if there is a need of calculate irradiance\n      this.environment.analyze(builder, {\n        cache: 'radiance',\n        context: contextEnvironment,\n        slot: 'radiance'\n      });\n      if (builder.requires.irradiance) {\n        this.environment.analyze(builder, {\n          cache: 'irradiance',\n          context: contextEnvironment,\n          slot: 'irradiance'\n        });\n      }\n    }\n    if (this.sheen) this.sheen.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color',\n      context: contextGammaOnly\n    });\n    var roughness = this.roughness.flow(builder, 'f');\n    var metalness = this.metalness.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var clearcoat = this.clearcoat ? this.clearcoat.flow(builder, 'f') : undefined;\n    var clearcoatRoughness = this.clearcoatRoughness ? this.clearcoatRoughness.flow(builder, 'f') : undefined;\n    var clearcoatNormal = this.clearcoatNormal ? this.clearcoatNormal.flow(builder, 'v3') : undefined;\n    var reflectivity = this.reflectivity ? this.reflectivity.flow(builder, 'f') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment;\n    if (this.environment) {\n      environment = {\n        radiance: this.environment.flow(builder, 'c', {\n          cache: 'radiance',\n          context: contextEnvironment,\n          slot: 'radiance'\n        })\n      };\n      if (builder.requires.irradiance) {\n        environment.irradiance = this.environment.flow(builder, 'c', {\n          cache: 'irradiance',\n          context: contextEnvironment,\n          slot: 'irradiance'\n        });\n      }\n    }\n    var clearcoatEnv = useClearcoat && environment ? this.environment.flow(builder, 'c', {\n      cache: 'clearcoat',\n      context: contextClearcoatEnvironment,\n      slot: 'environment'\n    }) : undefined;\n    var sheen = this.sheen ? this.sheen.flow(builder, 'c') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif', '#include <dithering_pars_fragment>', '#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_physical_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = ['#include <clipping_planes_fragment>',\n    // add before: prevent undeclared normal\n    '\t#include <normal_fragment_begin>', '\t#include <clearcoat_normal_fragment_begin>',\n    // add before: prevent undeclared material\n    '\tPhysicalMaterial material;', '\tmaterial.diffuseColor = vec3( 1.0 );'];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', roughness.code, '\tfloat roughnessFactor = ' + roughness.result + ';', metalness.code, '\tfloat metalnessFactor = ' + metalness.result + ';');\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', '\tif ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    }\n    if (clearcoatNormal) {\n      output.push(clearcoatNormal.code, 'clearcoatNormal = ' + clearcoatNormal.result + ';');\n    } // anti-aliasing code by @elalish\n\n    output.push('vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );'); // optimization for now\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor * ( 1.0 - metalnessFactor )') + ';', 'material.specularRoughness = max( roughnessFactor, 0.0525 );', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );');\n    if (clearcoat) {\n      output.push(clearcoat.code, 'material.clearcoat = saturate( ' + clearcoat.result + ' );' // Burley clearcoat model\n      );\n    } else if (useClearcoat) {\n      output.push('material.clearcoat = 0.0;');\n    }\n    if (clearcoatRoughness) {\n      output.push(clearcoatRoughness.code, 'material.clearcoatRoughness = max( ' + clearcoatRoughness.result + ', 0.0525 );', 'material.clearcoatRoughness += geometryRoughness;', 'material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );');\n    } else if (useClearcoat) {\n      output.push('material.clearcoatRoughness = 0.0;');\n    }\n    if (sheen) {\n      output.push('material.sheenColor = ' + sheen.result + ';');\n    }\n    if (reflectivity) {\n      output.push(reflectivity.code, 'material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( ' + reflectivity.result + ' ) ), diffuseColor, metalnessFactor );');\n    } else {\n      output.push('material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor, metalnessFactor );');\n    }\n    output.push('#include <lights_fragment_begin>');\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('diffuseColor *= 1.0 - metalnessFactor;', 'reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';', 'float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );', 'reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ' + ao.result + ', material.specularRoughness );');\n    }\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n    if (environment) {\n      output.push(environment.radiance.code);\n      if (builder.requires.irradiance) {\n        output.push(environment.irradiance.code);\n      }\n      if (clearcoatEnv) {\n        output.push(clearcoatEnv.code, 'clearcoatRadiance += ' + clearcoatEnv.result + ';');\n      }\n      output.push('radiance += ' + environment.radiance.result + ';');\n      if (builder.requires.irradiance) {\n        output.push('iblIrradiance += PI * ' + environment.irradiance.result + ';');\n      }\n    }\n    output.push('#include <lights_fragment_end>');\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;');\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>', '#include <dithering_fragment>');\n    code = output.join('\\n');\n  }\n  return code;\n};\nStandardNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.roughness = source.roughness;\n  this.metalness = source.metalness;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.clearcoat) this.clearcoat = source.clearcoat;\n  if (source.clearcoatRoughness) this.clearcoatRoughness = source.clearcoatRoughness;\n  if (source.clearcoatNormal) this.clearcoatNormal = source.clearcoatNormal;\n  if (source.reflectivity) this.reflectivity = source.reflectivity;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.sheen) this.sheen = source.sheen;\n  return this;\n};\nStandardNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.roughness = this.roughness.toJSON(meta).uuid;\n    data.metalness = this.metalness.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.clearcoat) data.clearcoat = this.clearcoat.toJSON(meta).uuid;\n    if (this.clearcoatRoughness) data.clearcoatRoughness = this.clearcoatRoughness.toJSON(meta).uuid;\n    if (this.clearcoatNormal) data.clearcoatNormal = this.clearcoatNormal.toJSON(meta).uuid;\n    if (this.reflectivity) data.reflectivity = this.reflectivity.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.sheen) data.sheen = this.sheen.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { StandardNode };","map":null,"metadata":{},"sourceType":"module"}