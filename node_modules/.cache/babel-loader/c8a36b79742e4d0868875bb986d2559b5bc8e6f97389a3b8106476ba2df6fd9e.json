{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmbeddedActionsParser = exports.CstParser = exports.Parser = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.DEFAULT_RULE_CONFIG = exports.DEFAULT_PARSER_CONFIG = exports.END_OF_FILE = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar follow_1 = require(\"../grammar/follow\");\n\nvar tokens_public_1 = require(\"../../scan/tokens_public\");\n\nvar errors_public_1 = require(\"../errors_public\");\n\nvar gast_resolver_public_1 = require(\"../grammar/gast/gast_resolver_public\");\n\nvar recoverable_1 = require(\"./traits/recoverable\");\n\nvar looksahead_1 = require(\"./traits/looksahead\");\n\nvar tree_builder_1 = require(\"./traits/tree_builder\");\n\nvar lexer_adapter_1 = require(\"./traits/lexer_adapter\");\n\nvar recognizer_api_1 = require(\"./traits/recognizer_api\");\n\nvar recognizer_engine_1 = require(\"./traits/recognizer_engine\");\n\nvar error_handler_1 = require(\"./traits/error_handler\");\n\nvar context_assist_1 = require(\"./traits/context_assist\");\n\nvar gast_recorder_1 = require(\"./traits/gast_recorder\");\n\nvar perf_tracer_1 = require(\"./traits/perf_tracer\");\n\nvar apply_mixins_1 = require(\"./utils/apply_mixins\");\n\nexports.END_OF_FILE = tokens_public_1.createTokenInstance(tokens_public_1.EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(exports.END_OF_FILE);\nexports.DEFAULT_PARSER_CONFIG = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: errors_public_1.defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n});\nexports.DEFAULT_RULE_CONFIG = Object.freeze({\n  recoveryValueFunc: function () {\n    return undefined;\n  },\n  resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n\n(function (ParserDefinitionErrorType) {\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n})(ParserDefinitionErrorType = exports.ParserDefinitionErrorType || (exports.ParserDefinitionErrorType = {}));\n\nfunction EMPTY_ALT(value) {\n  if (value === void 0) {\n    value = undefined;\n  }\n\n  return function () {\n    return value;\n  };\n}\n\nexports.EMPTY_ALT = EMPTY_ALT;\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(tokenVocabulary, config) {\n    this.definitionErrors = [];\n    this.selfAnalysisDone = false;\n    var that = this;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n\n    if (utils_1.has(config, \"ignoredIssues\")) {\n      throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" + \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" + \"For further details.\");\n    }\n\n    this.skipValidations = utils_1.has(config, \"skipValidations\") ? config.skipValidations : exports.DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n\n\n  Parser.performSelfAnalysis = function (parserInstance) {\n    throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" + \"\\t\\nUse the **instance** method with the same name instead.\");\n  };\n\n  Parser.prototype.performSelfAnalysis = function () {\n    var _this = this;\n\n    this.TRACE_INIT(\"performSelfAnalysis\", function () {\n      var defErrorsMsgs;\n      _this.selfAnalysisDone = true;\n      var className = _this.className;\n\n      _this.TRACE_INIT(\"toFastProps\", function () {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        utils_1.toFastProperties(_this);\n      });\n\n      _this.TRACE_INIT(\"Grammar Recording\", function () {\n        try {\n          _this.enableRecording(); // Building the GAST\n\n\n          utils_1.forEach(_this.definedRulesNames, function (currRuleName) {\n            var wrappedRule = _this[currRuleName];\n            var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            var recordedRuleGast = undefined;\n\n            _this.TRACE_INIT(currRuleName + \" Rule\", function () {\n              recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n            });\n\n            _this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          _this.disableRecording();\n        }\n      });\n\n      var resolverErrors = [];\n\n      _this.TRACE_INIT(\"Grammar Resolving\", function () {\n        resolverErrors = gast_resolver_public_1.resolveGrammar({\n          rules: utils_1.values(_this.gastProductionsCache)\n        });\n        _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);\n      });\n\n      _this.TRACE_INIT(\"Grammar Validations\", function () {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (utils_1.isEmpty(resolverErrors) && _this.skipValidations === false) {\n          var validationErrors = gast_resolver_public_1.validateGrammar({\n            rules: utils_1.values(_this.gastProductionsCache),\n            maxLookahead: _this.maxLookahead,\n            tokenTypes: utils_1.values(_this.tokensMap),\n            errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          });\n          _this.definitionErrors = _this.definitionErrors.concat(validationErrors);\n        }\n      }); // this analysis may fail if the grammar is not perfectly valid\n\n\n      if (utils_1.isEmpty(_this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (_this.recoveryEnabled) {\n          _this.TRACE_INIT(\"computeAllProdsFollows\", function () {\n            var allFollows = follow_1.computeAllProdsFollows(utils_1.values(_this.gastProductionsCache));\n            _this.resyncFollows = allFollows;\n          });\n        }\n\n        _this.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n          _this.preComputeLookaheadFunctions(utils_1.values(_this.gastProductionsCache));\n        });\n      }\n\n      if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !utils_1.isEmpty(_this.definitionErrors)) {\n        defErrorsMsgs = utils_1.map(_this.definitionErrors, function (defError) {\n          return defError.message;\n        });\n        throw new Error(\"Parser Definition Errors detected:\\n \" + defErrorsMsgs.join(\"\\n-------------------------------\\n\"));\n      }\n    });\n  }; // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n\n\n  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n  return Parser;\n}();\n\nexports.Parser = Parser;\napply_mixins_1.applyMixins(Parser, [recoverable_1.Recoverable, looksahead_1.LooksAhead, tree_builder_1.TreeBuilder, lexer_adapter_1.LexerAdapter, recognizer_engine_1.RecognizerEngine, recognizer_api_1.RecognizerApi, error_handler_1.ErrorHandler, context_assist_1.ContentAssist, gast_recorder_1.GastRecorder, perf_tracer_1.PerformanceTracer]);\n\nvar CstParser =\n/** @class */\nfunction (_super) {\n  __extends(CstParser, _super);\n\n  function CstParser(tokenVocabulary, config) {\n    if (config === void 0) {\n      config = exports.DEFAULT_PARSER_CONFIG;\n    }\n\n    var _this = this;\n\n    var configClone = utils_1.cloneObj(config);\n    configClone.outputCst = true;\n    _this = _super.call(this, tokenVocabulary, configClone) || this;\n    return _this;\n  }\n\n  return CstParser;\n}(Parser);\n\nexports.CstParser = CstParser;\n\nvar EmbeddedActionsParser =\n/** @class */\nfunction (_super) {\n  __extends(EmbeddedActionsParser, _super);\n\n  function EmbeddedActionsParser(tokenVocabulary, config) {\n    if (config === void 0) {\n      config = exports.DEFAULT_PARSER_CONFIG;\n    }\n\n    var _this = this;\n\n    var configClone = utils_1.cloneObj(config);\n    configClone.outputCst = false;\n    _this = _super.call(this, tokenVocabulary, configClone) || this;\n    return _this;\n  }\n\n  return EmbeddedActionsParser;\n}(Parser);\n\nexports.EmbeddedActionsParser = EmbeddedActionsParser;","map":{"version":3,"mappings":"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","names":["exports","tokens_public_1","NaN","Object","freeze","recoveryEnabled","maxLookahead","dynamicTokensEnabled","outputCst","errorMessageProvider","errors_public_1","nodeLocationTracking","traceInitPerf","skipValidations","recoveryValueFunc","resyncEnabled","ParserDefinitionErrorType","EMPTY_ALT","value","tokenVocabulary","config","that","initErrorHandler","initLexerAdapter","initLooksAhead","initRecognizerEngine","initRecoverable","initTreeBuilder","initContentAssist","initGastRecorder","initPerformanceTracer","utils_1","Error","Parser","parserInstance","TRACE_INIT","defErrorsMsgs","_this","selfAnalysisDone","className","enableRecording","definedRulesNames","currRuleName","wrappedRule","originalGrammarAction","recordedRuleGast","undefined","topLevelRuleRecord","gastProductionsCache","disableRecording","resolverErrors","gast_resolver_public_1","rules","definitionErrors","concat","validationErrors","tokenTypes","tokensMap","errMsgProvider","grammarName","allFollows","follow_1","resyncFollows","preComputeLookaheadFunctions","DEFER_DEFINITION_ERRORS_HANDLING","defError","message","join","apply_mixins_1","recoverable_1","looksahead_1","tree_builder_1","lexer_adapter_1","recognizer_engine_1","recognizer_api_1","error_handler_1","context_assist_1","gast_recorder_1","perf_tracer_1","__extends","configClone"],"sources":["/home/cliffexpc63/my example/portfolio/node_modules/chevrotain/src/parse/parser/parser.ts"],"sourcesContent":["import {\n  cloneObj,\n  forEach,\n  has,\n  isEmpty,\n  map,\n  values,\n  toFastProperties\n} from \"@chevrotain/utils\"\nimport { computeAllProdsFollows } from \"../grammar/follow\"\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public\"\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider\n} from \"../errors_public\"\nimport {\n  resolveGrammar,\n  validateGrammar\n} from \"../grammar/gast/gast_resolver_public\"\nimport {\n  CstNode,\n  IParserConfig,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport { Recoverable } from \"./traits/recoverable\"\nimport { LooksAhead } from \"./traits/looksahead\"\nimport { TreeBuilder } from \"./traits/tree_builder\"\nimport { LexerAdapter } from \"./traits/lexer_adapter\"\nimport { RecognizerApi } from \"./traits/recognizer_api\"\nimport { RecognizerEngine } from \"./traits/recognizer_engine\"\n\nimport { ErrorHandler } from \"./traits/error_handler\"\nimport { MixedInParser } from \"./traits/parser_traits\"\nimport { ContentAssist } from \"./traits/context_assist\"\nimport { GastRecorder } from \"./traits/gast_recorder\"\nimport { PerformanceTracer } from \"./traits/perf_tracer\"\nimport { applyMixins } from \"./utils/apply_mixins\"\nimport { IParserDefinitionError } from \"../grammar/types\"\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN\n)\nObject.freeze(END_OF_FILE)\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean\n\nexport type lookAheadSequence = TokenType[][]\n\nexport const DEFAULT_PARSER_CONFIG: IParserConfig = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n})\n\nexport const DEFAULT_RULE_CONFIG: IRuleConfig<any> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true\n})\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string\n  occurrence: number\n  parameter?: string\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternative: number\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternatives: number[]\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[]\n  lexerState: any\n  RULE_STACK: string[]\n  CST_STACK: CstNode[]\n}\n\nexport type Predicate = () => boolean\n\nexport function EMPTY_ALT<T>(value: T = undefined): () => T {\n  return function () {\n    return value\n  }\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\"\n    )\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs\n\n      this.selfAnalysisDone = true\n      const className = this.className\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this)\n      })\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording()\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = this[currRuleName]\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"]\n            let recordedRuleGast = undefined\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction\n              )\n            })\n            this.gastProductionsCache[currRuleName] = recordedRuleGast\n          })\n        } finally {\n          this.disableRecording()\n        }\n      })\n\n      let resolverErrors = []\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache)\n        })\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n      })\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            maxLookahead: this.maxLookahead,\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          })\n          this.definitionErrors = this.definitionErrors.concat(validationErrors)\n        }\n      })\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache)\n            )\n            this.resyncFollows = allFollows\n          })\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n        })\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message\n        )\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\"\n          )}`\n        )\n      }\n    })\n  }\n\n  definitionErrors: IParserDefinitionError[] = []\n  selfAnalysisDone = false\n  protected skipValidations: boolean\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any\n    that.initErrorHandler(config)\n    that.initLexerAdapter()\n    that.initLooksAhead(config)\n    that.initRecognizerEngine(tokenVocabulary, config)\n    that.initRecoverable(config)\n    that.initTreeBuilder(config)\n    that.initContentAssist()\n    that.initGastRecorder(config)\n    that.initPerformanceTracer(config)\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\"\n      )\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? config.skipValidations\n      : DEFAULT_PARSER_CONFIG.skipValidations\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n])\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = cloneObj(config)\n    configClone.outputCst = true\n    super(tokenVocabulary, configClone)\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = cloneObj(config)\n    configClone.outputCst = false\n    super(tokenVocabulary, configClone)\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}