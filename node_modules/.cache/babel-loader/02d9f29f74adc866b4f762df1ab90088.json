{"ast":null,"code":"import _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e8) { throw _e8; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e9) { didErr = true; err = _e9; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar t = new Uint8Array([0]),\n  e = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nvar n, i, s, a, r, o, l, f;\n!function (t) {\n  t[t.NONE = 0] = \"NONE\", t[t.BASISLZ = 1] = \"BASISLZ\", t[t.ZSTD = 2] = \"ZSTD\", t[t.ZLIB = 3] = \"ZLIB\";\n}(n || (n = {})), function (t) {\n  t[t.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(i || (i = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.ETC1S = 163] = \"ETC1S\", t[t.UASTC = 166] = \"UASTC\";\n}(s || (s = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.SRGB = 1] = \"SRGB\";\n}(a || (a = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.LINEAR = 1] = \"LINEAR\", t[t.SRGB = 2] = \"SRGB\", t[t.ITU = 3] = \"ITU\", t[t.NTSC = 4] = \"NTSC\", t[t.SLOG = 5] = \"SLOG\", t[t.SLOG2 = 6] = \"SLOG2\";\n}(r || (r = {})), function (t) {\n  t[t.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", t[t.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(o || (o = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RRR = 3] = \"RRR\", t[t.GGG = 4] = \"GGG\", t[t.AAA = 15] = \"AAA\";\n}(l || (l = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RGBA = 3] = \"RGBA\", t[t.RRR = 4] = \"RRR\", t[t.RRRG = 5] = \"RRRG\";\n}(f || (f = {}));\nvar U = function U() {\n  _classCallCheck(this, U);\n  this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [{\n    vendorId: 0,\n    descriptorType: i.BASICFORMAT,\n    versionNumber: 2,\n    descriptorBlockSize: 40,\n    colorModel: s.UNSPECIFIED,\n    colorPrimaries: a.SRGB,\n    transferFunction: a.SRGB,\n    flags: o.ALPHA_STRAIGHT,\n    texelBlockDimension: {\n      x: 4,\n      y: 4,\n      z: 1,\n      w: 1\n    },\n    bytesPlane: [],\n    samples: []\n  }], this.keyValue = {}, this.globalData = null;\n};\nvar c = /*#__PURE__*/function () {\n  function c(t, e, n, i) {\n    _classCallCheck(this, c);\n    this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0;\n  }\n  _createClass(c, [{\n    key: \"_nextUint8\",\n    value: function _nextUint8() {\n      var t = this._dataView.getUint8(this._offset);\n      return this._offset += 1, t;\n    }\n  }, {\n    key: \"_nextUint16\",\n    value: function _nextUint16() {\n      var t = this._dataView.getUint16(this._offset, this._littleEndian);\n      return this._offset += 2, t;\n    }\n  }, {\n    key: \"_nextUint32\",\n    value: function _nextUint32() {\n      var t = this._dataView.getUint32(this._offset, this._littleEndian);\n      return this._offset += 4, t;\n    }\n  }, {\n    key: \"_nextUint64\",\n    value: function _nextUint64() {\n      var t = this._dataView.getUint32(this._offset, this._littleEndian) + Math.pow(2, 32) * this._dataView.getUint32(this._offset + 4, this._littleEndian);\n      return this._offset += 8, t;\n    }\n  }, {\n    key: \"_skip\",\n    value: function _skip(t) {\n      return this._offset += t, this;\n    }\n  }, {\n    key: \"_scan\",\n    value: function _scan(t) {\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var n = this._offset;\n      var i = 0;\n      for (; this._dataView.getUint8(this._offset) !== e && i < t;) {\n        i++, this._offset++;\n      }\n      return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);\n    }\n  }]);\n  return c;\n}();\nfunction h(t) {\n  return \"undefined\" != typeof TextEncoder ? new TextEncoder().encode(t) : Buffer.from(t);\n}\nfunction _(t) {\n  return \"undefined\" != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString(\"utf8\");\n}\nfunction g(t) {\n  var e = 0;\n  var _iterator = _createForOfIteratorHelper(t),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _n = _step.value;\n      e += _n.byteLength;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var n = new Uint8Array(e);\n  var i = 0;\n  var _iterator2 = _createForOfIteratorHelper(t),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _e = _step2.value;\n      n.set(new Uint8Array(_e), i), i += _e.byteLength;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return n;\n}\nfunction p(t) {\n  var n = new Uint8Array(t.buffer, t.byteOffset, e.length);\n  if (n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] || n[6] !== e[6] || n[7] !== e[7] || n[8] !== e[8] || n[9] !== e[9] || n[10] !== e[10] || n[11] !== e[11]) throw new Error(\"Missing KTX 2.0 identifier.\");\n  var i = new U(),\n    s = 17 * Uint32Array.BYTES_PER_ELEMENT,\n    a = new c(t, e.length, s, !0);\n  i.vkFormat = a._nextUint32(), i.typeSize = a._nextUint32(), i.pixelWidth = a._nextUint32(), i.pixelHeight = a._nextUint32(), i.pixelDepth = a._nextUint32(), i.layerCount = a._nextUint32(), i.faceCount = a._nextUint32();\n  var r = a._nextUint32();\n  i.supercompressionScheme = a._nextUint32();\n  var o = a._nextUint32(),\n    l = a._nextUint32(),\n    f = a._nextUint32(),\n    h = a._nextUint32(),\n    g = a._nextUint64(),\n    p = a._nextUint64(),\n    x = new c(t, e.length + s, 3 * r * 8, !0);\n  for (var _e2 = 0; _e2 < r; _e2++) {\n    i.levels.push({\n      levelData: new Uint8Array(t.buffer, t.byteOffset + x._nextUint64(), x._nextUint64()),\n      uncompressedByteLength: x._nextUint64()\n    });\n  }\n  var u = new c(t, o, l, !0),\n    y = {\n      vendorId: u._skip(4)._nextUint16(),\n      descriptorType: u._nextUint16(),\n      versionNumber: u._nextUint16(),\n      descriptorBlockSize: u._nextUint16(),\n      colorModel: u._nextUint8(),\n      colorPrimaries: u._nextUint8(),\n      transferFunction: u._nextUint8(),\n      flags: u._nextUint8(),\n      texelBlockDimension: {\n        x: u._nextUint8() + 1,\n        y: u._nextUint8() + 1,\n        z: u._nextUint8() + 1,\n        w: u._nextUint8() + 1\n      },\n      bytesPlane: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n      samples: []\n    },\n    D = (y.descriptorBlockSize / 4 - 6) / 4;\n  for (var _t = 0; _t < D; _t++) {\n    y.samples[_t] = {\n      bitOffset: u._nextUint16(),\n      bitLength: u._nextUint8(),\n      channelID: u._nextUint8(),\n      samplePosition: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n      sampleLower: u._nextUint32(),\n      sampleUpper: u._nextUint32()\n    };\n  }\n  i.dataFormatDescriptor.length = 0, i.dataFormatDescriptor.push(y);\n  var b = new c(t, f, h, !0);\n  for (; b._offset < h;) {\n    var _t2 = b._nextUint32(),\n      _e3 = b._scan(_t2),\n      _n2 = _(_e3),\n      _s = b._scan(_t2 - _e3.byteLength);\n    i.keyValue[_n2] = _n2.match(/^ktx/i) ? _(_s) : _s, b._offset % 4 && b._skip(4 - b._offset % 4);\n  }\n  if (p <= 0) return i;\n  var d = new c(t, g, p, !0),\n    B = d._nextUint16(),\n    w = d._nextUint16(),\n    A = d._nextUint32(),\n    S = d._nextUint32(),\n    m = d._nextUint32(),\n    L = d._nextUint32(),\n    I = [];\n  for (var _t3 = 0; _t3 < r; _t3++) {\n    I.push({\n      imageFlags: d._nextUint32(),\n      rgbSliceByteOffset: d._nextUint32(),\n      rgbSliceByteLength: d._nextUint32(),\n      alphaSliceByteOffset: d._nextUint32(),\n      alphaSliceByteLength: d._nextUint32()\n    });\n  }\n  var R = g + d._offset,\n    E = R + A,\n    T = E + S,\n    O = T + m,\n    P = new Uint8Array(t.buffer, t.byteOffset + R, A),\n    C = new Uint8Array(t.buffer, t.byteOffset + E, S),\n    F = new Uint8Array(t.buffer, t.byteOffset + T, m),\n    G = new Uint8Array(t.buffer, t.byteOffset + O, L);\n  return i.globalData = {\n    endpointCount: B,\n    selectorCount: w,\n    imageDescs: I,\n    endpointsData: P,\n    selectorsData: C,\n    tablesData: F,\n    extendedData: G\n  }, i;\n}\nfunction x() {\n  return (x = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var i in n) {\n        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n      }\n    }\n    return t;\n  }).apply(this, arguments);\n}\nvar u = {\n  keepWriter: !1\n};\nfunction y(n) {\n  var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  s = x({}, u, s);\n  var a = new ArrayBuffer(0);\n  if (n.globalData) {\n    var _t4 = new ArrayBuffer(20 + 5 * n.globalData.imageDescs.length * 4),\n      _e4 = new DataView(_t4);\n    _e4.setUint16(0, n.globalData.endpointCount, !0), _e4.setUint16(2, n.globalData.selectorCount, !0), _e4.setUint32(4, n.globalData.endpointsData.byteLength, !0), _e4.setUint32(8, n.globalData.selectorsData.byteLength, !0), _e4.setUint32(12, n.globalData.tablesData.byteLength, !0), _e4.setUint32(16, n.globalData.extendedData.byteLength, !0);\n    for (var _t5 = 0; _t5 < n.globalData.imageDescs.length; _t5++) {\n      var _i = n.globalData.imageDescs[_t5];\n      _e4.setUint32(20 + 5 * _t5 * 4 + 0, _i.imageFlags, !0), _e4.setUint32(20 + 5 * _t5 * 4 + 4, _i.rgbSliceByteOffset, !0), _e4.setUint32(20 + 5 * _t5 * 4 + 8, _i.rgbSliceByteLength, !0), _e4.setUint32(20 + 5 * _t5 * 4 + 12, _i.alphaSliceByteOffset, !0), _e4.setUint32(20 + 5 * _t5 * 4 + 16, _i.alphaSliceByteLength, !0);\n    }\n    a = g([_t4, n.globalData.endpointsData, n.globalData.selectorsData, n.globalData.tablesData, n.globalData.extendedData]);\n  }\n  var r = [];\n  var o = n.keyValue;\n  s.keepWriter || (o = x({}, n.keyValue, {\n    KTXwriter: \"KTX-Parse v0.2.1\"\n  }));\n  for (var _e5 in o) {\n    var _n3 = o[_e5],\n      _i2 = h(_e5),\n      _s2 = \"string\" == typeof _n3 ? h(_n3) : _n3,\n      _a = _i2.byteLength + 1 + _s2.byteLength + 1,\n      _l = _a % 4 ? 4 - _a % 4 : 0;\n    r.push(g([new Uint32Array([_a]), _i2, t, _s2, t, new Uint8Array(_l).fill(0)]));\n  }\n  var l = g(r),\n    f = new ArrayBuffer(44),\n    U = new DataView(f);\n  if (1 !== n.dataFormatDescriptor.length || n.dataFormatDescriptor[0].descriptorType !== i.BASICFORMAT) throw new Error(\"Only BASICFORMAT Data Format Descriptor output supported.\");\n  var c = n.dataFormatDescriptor[0];\n  U.setUint32(0, 44, !0), U.setUint16(4, c.vendorId, !0), U.setUint16(6, c.descriptorType, !0), U.setUint16(8, c.versionNumber, !0), U.setUint16(10, c.descriptorBlockSize, !0), U.setUint8(12, c.colorModel), U.setUint8(13, c.colorPrimaries), U.setUint8(14, c.transferFunction), U.setUint8(15, c.flags), U.setUint8(16, c.texelBlockDimension.x - 1), U.setUint8(17, c.texelBlockDimension.y - 1), U.setUint8(18, c.texelBlockDimension.z - 1), U.setUint8(19, c.texelBlockDimension.w - 1);\n  for (var _t6 = 0; _t6 < 8; _t6++) {\n    U.setUint8(20 + _t6, c.bytesPlane[_t6]);\n  }\n  for (var _t7 = 0; _t7 < c.samples.length; _t7++) {\n    var _e6 = c.samples[_t7],\n      _n4 = 28 + 16 * _t7;\n    U.setUint16(_n4 + 0, _e6.bitOffset, !0), U.setUint8(_n4 + 2, _e6.bitLength), U.setUint8(_n4 + 3, _e6.channelID), U.setUint8(_n4 + 4, _e6.samplePosition[0]), U.setUint8(_n4 + 5, _e6.samplePosition[1]), U.setUint8(_n4 + 6, _e6.samplePosition[2]), U.setUint8(_n4 + 7, _e6.samplePosition[3]), U.setUint32(_n4 + 8, _e6.sampleLower, !0), U.setUint32(_n4 + 12, _e6.sampleUpper, !0);\n  }\n  var _ = e.length + 68 + 3 * n.levels.length * 8,\n    p = _ + f.byteLength;\n  var y = p + l.byteLength;\n  y % 8 && (y += 8 - y % 8);\n  var D = [],\n    b = new DataView(new ArrayBuffer(3 * n.levels.length * 8));\n  var d = y + a.byteLength;\n  for (var _t8 = 0; _t8 < n.levels.length; _t8++) {\n    var _e7 = n.levels[_t8];\n    D.push(_e7.levelData), b.setBigUint64(24 * _t8 + 0, BigInt(d), !0), b.setBigUint64(24 * _t8 + 8, BigInt(_e7.levelData.byteLength), !0), b.setBigUint64(24 * _t8 + 16, BigInt(_e7.uncompressedByteLength), !0), d += _e7.levelData.byteLength;\n  }\n  var B = new ArrayBuffer(68),\n    w = new DataView(B);\n  return w.setUint32(0, n.vkFormat, !0), w.setUint32(4, n.typeSize, !0), w.setUint32(8, n.pixelWidth, !0), w.setUint32(12, n.pixelHeight, !0), w.setUint32(16, n.pixelDepth, !0), w.setUint32(20, n.layerCount, !0), w.setUint32(24, n.faceCount, !0), w.setUint32(28, n.levels.length, !0), w.setUint32(32, n.supercompressionScheme, !0), w.setUint32(36, _, !0), w.setUint32(40, f.byteLength, !0), w.setUint32(44, p, !0), w.setUint32(48, l.byteLength, !0), w.setBigUint64(52, BigInt(y), !0), w.setBigUint64(60, BigInt(a.byteLength), !0), new Uint8Array(g([new Uint8Array(e).buffer, B, b.buffer, f, l, new ArrayBuffer(y - (p + l.byteLength)), a].concat(D)));\n}\nexport { l as KTX2ChannelETC1S, f as KTX2ChannelUASTC, U as KTX2Container, i as KTX2DescriptorType, o as KTX2Flags, s as KTX2Model, a as KTX2Primaries, n as KTX2SupercompressionScheme, r as KTX2Transfer, p as read, y as write };","map":null,"metadata":{},"sourceType":"module"}