{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\nvar cst_1 = require(\"../../cst/cst\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\nvar parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */function () {\n  function TreeBuilder() {}\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = [];\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = utils_1.has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = utils_1.NOOP;\n      this.cstFinallyStateUpdate = utils_1.NOOP;\n      this.cstPostTerminal = utils_1.NOOP;\n      this.cstPostNonTerminal = utils_1.NOOP;\n      this.cstPostRule = utils_1.NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = utils_1.NOOP;\n        this.setNodeLocationFromNode = utils_1.NOOP;\n        this.cstPostRule = utils_1.NOOP;\n        this.setInitialNodeLocation = utils_1.NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n  return TreeBuilder;\n}();\nexports.TreeBuilder = TreeBuilder;","map":null,"metadata":{},"sourceType":"script"}