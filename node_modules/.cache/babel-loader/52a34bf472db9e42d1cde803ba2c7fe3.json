{"ast":null,"code":"import _toConsumableArray from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport { Vector3, BufferAttribute, Box3 } from 'three';\nimport { CENTER } from './Constants.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar obb = new OrientedBox();\nvar obb2 = new OrientedBox();\nvar temp = new Vector3();\nvar temp1 = new Vector3();\nvar temp2 = new Vector3();\nvar tempBox = new Box3();\nvar triangle = new SeparatingAxisTriangle();\nvar triangle2 = new SeparatingAxisTriangle();\nvar MeshBVH = /*#__PURE__*/function () {\n  _createClass(MeshBVH, null, [{\n    key: \"serialize\",\n    value: function serialize(bvh, geometry) {\n      var copyIndexBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result = {\n        roots: rootData,\n        index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\n      };\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var setIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var index = data.index,\n        roots = data.roots;\n      var bvh = new MeshBVH(geometry, _defineProperty({}, SKIP_GENERATION, true));\n      bvh._roots = roots;\n      if (setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      setBoundingBox: true\n    }, SKIP_GENERATION, false), options);\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\n    this._roots = null;\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n  }\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var terminationIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n      if (terminationIndices && Array.isArray(terminationIndices)) {\n        terminationIndices = new Set(terminationIndices);\n      }\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var posArr = posAttr.array;\n\n      // support for an interleaved position buffer\n      var bufferOffset = posAttr.offset || 0;\n      var stride = 3;\n      if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n      }\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n      }\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i] * stride + bufferOffset;\n            var x = posArr[index + 0];\n            var y = posArr[index + 1];\n            var z = posArr[index + 2];\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6];\n\n          // the indentifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var leftChange = false;\n          var forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\n          var traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceLeft);\n          }\n          var rightChange = false;\n          var forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\n          var traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceRight);\n          }\n          var didChange = leftChange || rightChange;\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    } /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(mesh, raycaster, ray, intersects) {\n      var geometry = this.geometry;\n      var localIntersects = intersects ? [] : null;\n      var _iterator = _createForOfIteratorHelper(this._roots),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          _raycast(0, mesh, geometry, raycaster, ray, localIntersects);\n          clearBuffer();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (intersects) {\n        for (var i = 0, l = localIntersects.length; i < l; i++) {\n          delete localIntersects[i].localPoint;\n        }\n        intersects.push.apply(intersects, _toConsumableArray(localIntersects));\n      }\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(mesh, raycaster, ray) {\n      var geometry = this.geometry;\n      var closestResult = null;\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          var result = _raycastFirst(0, mesh, geometry, raycaster, ray);\n          clearBuffer();\n          if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n            closestResult = result;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (closestResult) {\n        delete closestResult.localPoint;\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(mesh, otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n      var _iterator3 = _createForOfIteratorHelper(this._roots),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var root = _step3.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, mesh, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n      var _callbacks = callbacks,\n        boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n        intersectsBounds = _callbacks.intersectsBounds,\n        intersectsRange = _callbacks.intersectsRange,\n        intersectsTriangle = _callbacks.intersectsTriangle;\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n      var result = false;\n      var byteOffset = 0;\n      var _iterator4 = _createForOfIteratorHelper(this._roots),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var root = _step4.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return result;\n    } /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(mesh, box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(mesh, sphere) {\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(mesh, otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var target2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var minThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var maxThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Infinity;\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var tempTarget1 = null;\n      var tempTarget2 = null;\n      if (target1) {\n        tempTarget1 = temp1;\n      }\n      if (target2) {\n        tempTarget2 = temp2;\n      }\n      var closestDistance = Infinity;\n      obb2.matrix.copy(geometryToBvh).invert();\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n            return true;\n          }\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast(null, {\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                    if (dist < closestDistance) {\n                      if (target1) {\n                        target1.copy(tempTarget1);\n                      }\n                      if (target2) {\n                        target2.copy(tempTarget2);\n                      }\n                      closestDistance = dist;\n                    }\n\n                    // stop traversal if we find a point that's under the given threshold\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                if (dist < closestDistance) {\n                  if (target1) {\n                    target1.copy(tempTarget1);\n                  }\n                  if (target2) {\n                    target2.copy(tempTarget2);\n                  }\n                  closestDistance = dist;\n                }\n\n                // stop traversal if we find a point that's under the given threshold\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      return closestDistance;\n    }\n  }, {\n    key: \"distanceToGeometry\",\n    value: function distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\n      return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(mesh, point, target) {\n      var minThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var maxThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n          if (distSq < closestDistanceSq) {\n            if (target) {\n              target.copy(temp);\n            }\n            closestDistanceSq = distSq;\n          }\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      return Math.sqrt(closestDistanceSq);\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(mesh, point, minThreshold, maxThreshold) {\n      return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }]);\n  return MeshBVH;\n}();\nexport { MeshBVH as default };","map":null,"metadata":{},"sourceType":"module"}