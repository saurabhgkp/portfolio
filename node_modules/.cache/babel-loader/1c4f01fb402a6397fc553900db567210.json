{"ast":null,"code":"import _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nvar box1 = new Box3();\nvar box2 = new Box3();\nvar vec = new Vector3();\nexport var MeshBVHDebug = /*#__PURE__*/function () {\n  function MeshBVHDebug(bvh, geometry) {\n    _classCallCheck(this, MeshBVHDebug);\n    this.bvh = bvh;\n    this.geometry = geometry;\n  }\n\n  // Returns a simple, human readable object that represents the BVH.\n  _createClass(MeshBVHDebug, [{\n    key: \"getJSONStructure\",\n    value: function getJSONStructure() {\n      var bvh = this.bvh;\n      var depthStack = [];\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          bounds: arrayToBox(boundingData, new Box3())\n        };\n        if (isLeaf) {\n          info.count = count;\n          info.offset = offset;\n        } else {\n          info.left = null;\n          info.right = null;\n        }\n        depthStack[depth] = info;\n\n        // traversal hits the left then right node\n        var parent = depthStack[depth - 1];\n        if (parent) {\n          if (parent.left === null) {\n            parent.left = info;\n          } else {\n            parent.right = info;\n          }\n        }\n      });\n      return depthStack[0];\n    }\n  }, {\n    key: \"validateBounds\",\n    value: function validateBounds() {\n      var bvh = this.bvh,\n        geometry = this.geometry;\n      var depthStack = [];\n      var index = geometry.index;\n      var position = geometry.getAttribute('position');\n      var passes = true;\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          depth: depth,\n          isLeaf: isLeaf,\n          boundingData: boundingData,\n          offset: offset,\n          count: count\n        };\n        depthStack[depth] = info;\n        arrayToBox(boundingData, box1);\n        var parent = depthStack[depth - 1];\n        if (isLeaf) {\n          // check triangles\n          for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n            var i0 = index.getX(i);\n            var i1 = index.getX(i + 1);\n            var i2 = index.getX(i + 2);\n            var isContained = void 0;\n            vec.fromBufferAttribute(position, i0);\n            isContained = box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i1);\n            isContained = isContained && box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i2);\n            isContained = isContained && box1.containsPoint(vec);\n            console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n            passes = passes && isContained;\n          }\n        }\n        if (parent) {\n          // check if my bounds fit in my parents\n          arrayToBox(boundingData, box2);\n          var _isContained = box2.containsBox(box1);\n          console.assert(_isContained, 'Parent bounds does not fully contain child.');\n          passes = passes && _isContained;\n        }\n      });\n      return passes;\n    }\n  }]);\n  return MeshBVHDebug;\n}();","map":null,"metadata":{},"sourceType":"module"}