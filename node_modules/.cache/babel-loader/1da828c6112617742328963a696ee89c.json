{"ast":null,"code":"import { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nconst box1 = new Box3();\nconst box2 = new Box3();\nconst vec = new Vector3();\nexport class MeshBVHDebug {\n  constructor(bvh, geometry) {\n    this.bvh = bvh;\n    this.geometry = geometry;\n  } // Returns a simple, human readable object that represents the BVH.\n\n\n  getJSONStructure() {\n    const {\n      bvh\n    } = this;\n    const depthStack = [];\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        bounds: arrayToBox(boundingData, new Box3())\n      };\n\n      if (isLeaf) {\n        info.count = count;\n        info.offset = offset;\n      } else {\n        info.left = null;\n        info.right = null;\n      }\n\n      depthStack[depth] = info; // traversal hits the left then right node\n\n      const parent = depthStack[depth - 1];\n\n      if (parent) {\n        if (parent.left === null) {\n          parent.left = info;\n        } else {\n          parent.right = info;\n        }\n      }\n    });\n    return depthStack[0];\n  }\n\n  validateBounds() {\n    const {\n      bvh,\n      geometry\n    } = this;\n    const depthStack = [];\n    const index = geometry.index;\n    const position = geometry.getAttribute('position');\n    let passes = true;\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        depth,\n        isLeaf,\n        boundingData,\n        offset,\n        count\n      };\n      depthStack[depth] = info;\n      arrayToBox(boundingData, box1);\n      const parent = depthStack[depth - 1];\n\n      if (isLeaf) {\n        // check triangles\n        for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n          const i0 = index.getX(i);\n          const i1 = index.getX(i + 1);\n          const i2 = index.getX(i + 2);\n          let isContained;\n          vec.fromBufferAttribute(position, i0);\n          isContained = box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i1);\n          isContained = isContained && box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i2);\n          isContained = isContained && box1.containsPoint(vec);\n          console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n          passes = passes && isContained;\n        }\n      }\n\n      if (parent) {\n        // check if my bounds fit in my parents\n        arrayToBox(boundingData, box2);\n        const isContained = box2.containsBox(box1);\n        console.assert(isContained, 'Parent bounds does not fully contain child.');\n        passes = passes && isContained;\n      }\n    });\n    return passes;\n  }\n\n}","map":{"version":3,"names":["Box3","Vector3","arrayToBox","box1","box2","vec","MeshBVHDebug","constructor","bvh","geometry","getJSONStructure","depthStack","traverse","depth","isLeaf","boundingData","offset","count","info","bounds","left","right","parent","validateBounds","index","position","getAttribute","passes","i","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox"],"sources":["/home/cliffexpc63/my example/portfolioQ/node_modules/three-mesh-bvh/src/MeshBVHDebug.js"],"sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nconst box1 = new Box3();\r\nconst box2 = new Box3();\r\nconst vec = new Vector3();\r\n\r\nexport class MeshBVHDebug {\r\n\r\n\tconstructor( bvh, geometry ) {\r\n\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\t// Returns a simple, human readable object that represents the BVH.\r\n\tgetJSONStructure() {\r\n\r\n\t\tconst { bvh } = this;\r\n\t\tconst depthStack = [];\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tbounds: arrayToBox( boundingData, new Box3() ),\r\n\t\t\t};\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tinfo.count = count;\r\n\t\t\t\tinfo.offset = offset;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinfo.left = null;\r\n\t\t\t\tinfo.right = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\t// traversal hits the left then right node\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\t\tparent.left = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparent.right = info;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn depthStack[ 0 ];\r\n\r\n\t}\r\n\r\n\tvalidateBounds() {\r\n\r\n\t\tconst { bvh, geometry } = this;\r\n\t\tconst depthStack = [];\r\n\t\tconst index = geometry.index;\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\t\tlet passes = true;\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tdepth,\r\n\t\t\t\tisLeaf,\r\n\t\t\t\tboundingData,\r\n\t\t\t\toffset,\r\n\t\t\t\tcount,\r\n\t\t\t};\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\tarrayToBox( boundingData, box1 );\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t// check triangles\r\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i0 );\r\n\t\t\t\t\tisContained = box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i1 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i2 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t// check if my bounds fit in my parents\r\n\t\t\t\tarrayToBox( boundingData, box2 );\r\n\r\n\t\t\t\tconst isContained = box2.containsBox( box1 );\r\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn passes;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}