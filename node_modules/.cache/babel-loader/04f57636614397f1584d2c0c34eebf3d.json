{"ast":null,"code":"import { InputNode } from '../core/InputNode.js';\nimport { UVNode } from '../accessors/UVNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nfunction TextureNode(value, uv, bias, project) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new UVNode();\n  this.bias = bias;\n  this.project = project !== undefined ? project : false;\n}\nTextureNode.prototype = Object.create(InputNode.prototype);\nTextureNode.prototype.constructor = TextureNode;\nTextureNode.prototype.nodeType = 'Texture';\nTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 't');\n};\nTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'sampler2D') {\n    return this.getTexture(builder, output);\n  }\n  var tex = this.getTexture(builder, output),\n    uv = this.uv.build(builder, this.project ? 'v4' : 'v2'),\n    bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n  var method, code;\n  if (this.project) method = 'texture2DProj';else method = bias ? 'tex2DBias' : 'tex2D';\n  if (bias) code = method + '( ' + tex + ', ' + uv + ', ' + bias + ' )';else code = method + '( ' + tex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\nTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  if (source.project !== undefined) this.project = source.project;\n  return this;\n};\nTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    if (this.value) data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.project = this.project;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { TextureNode };","map":null,"metadata":{},"sourceType":"module"}