{"ast":null,"code":"/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nvar DRACOExporter = function DRACOExporter() {};\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function parse(object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n    var geometry = object.geometry;\n    var dracoEncoder = DracoEncoderModule();\n    var encoder = new dracoEncoder.Encoder();\n    var builder;\n    var dracoObject;\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n        for (var i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n      if (options.exportNormals === true) {\n        var normals = geometry.getAttribute('normal');\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n      if (options.exportUvs === true) {\n        var uvs = geometry.getAttribute('uv');\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n    var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    var encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    var decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n    if (options.quantization !== undefined) {\n      for (var _i = 0; _i < 5; _i++) {\n        if (options.quantization[_i] !== undefined) {\n          encoder.SetAttributeQuantization(_i, options.quantization[_i]);\n        }\n      }\n    }\n    var length;\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n    dracoEncoder.destroy(dracoObject);\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n    var outputData = new Int8Array(new ArrayBuffer(length));\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      outputData[_i2] = encodedData.GetValue(_i2);\n    }\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\nexport { DRACOExporter };","map":null,"metadata":{},"sourceType":"module"}