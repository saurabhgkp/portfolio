{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nfunction MathNode(a, bOrMethod, cOrMethod, method) {\n  TempNode.call(this);\n  this.a = a;\n  typeof bOrMethod !== 'string' ? this.b = bOrMethod : method = bOrMethod;\n  typeof cOrMethod !== 'string' ? this.c = cOrMethod : method = cOrMethod;\n  this.method = method;\n} // 1 input\n\nMathNode.RAD = 'radians';\nMathNode.DEG = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INV_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SATURATE = 'saturate';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ARCTAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.INVERT = 'invert'; // 2 inputs\n\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow'; // 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\nMathNode.prototype = Object.create(TempNode.prototype);\nMathNode.prototype.constructor = MathNode;\nMathNode.prototype.nodeType = 'Math';\nMathNode.prototype.hashProperties = ['method'];\nMathNode.prototype.getNumInputs = function () /*builder*/\n{\n  switch (this.method) {\n    case MathNode.MIX:\n    case MathNode.CLAMP:\n    case MathNode.REFRACT:\n    case MathNode.SMOOTHSTEP:\n    case MathNode.FACEFORWARD:\n      return 3;\n    case MathNode.MIN:\n    case MathNode.MAX:\n    case MathNode.MOD:\n    case MathNode.STEP:\n    case MathNode.REFLECT:\n    case MathNode.DISTANCE:\n    case MathNode.DOT:\n    case MathNode.CROSS:\n    case MathNode.POW:\n      return 2;\n    default:\n      return 1;\n  }\n};\nMathNode.prototype.getInputType = function (builder) {\n  var a = builder.getTypeLength(this.a.getType(builder));\n  var b = this.b ? builder.getTypeLength(this.b.getType(builder)) : 0;\n  var c = this.c ? builder.getTypeLength(this.c.getType(builder)) : 0;\n  if (a > b && a > c) {\n    return this.a.getType(builder);\n  } else if (b > c) {\n    return this.b.getType(builder);\n  }\n  return this.c.getType(builder);\n};\nMathNode.prototype.getType = function (builder) {\n  switch (this.method) {\n    case MathNode.LENGTH:\n    case MathNode.DISTANCE:\n    case MathNode.DOT:\n      return 'f';\n    case MathNode.CROSS:\n      return 'v3';\n  }\n  return this.getInputType(builder);\n};\nMathNode.prototype.generate = function (builder, output) {\n  var a,\n    b,\n    c,\n    al = this.a ? builder.getTypeLength(this.a.getType(builder)) : 0,\n    bl = this.b ? builder.getTypeLength(this.b.getType(builder)) : 0,\n    cl = this.c ? builder.getTypeLength(this.c.getType(builder)) : 0,\n    inputType = this.getInputType(builder),\n    nodeType = this.getType(builder);\n  switch (this.method) {\n    // 1 input\n    case MathNode.NEGATE:\n      return builder.format('( -' + this.a.build(builder, inputType) + ' )', inputType, output);\n    case MathNode.INVERT:\n      return builder.format('( 1.0 - ' + this.a.build(builder, inputType) + ' )', inputType, output);\n    // 2 inputs\n\n    case MathNode.CROSS:\n      a = this.a.build(builder, 'v3');\n      b = this.b.build(builder, 'v3');\n      break;\n    case MathNode.STEP:\n      a = this.a.build(builder, al === 1 ? 'f' : inputType);\n      b = this.b.build(builder, inputType);\n      break;\n    case MathNode.MIN:\n    case MathNode.MAX:\n    case MathNode.MOD:\n      a = this.a.build(builder, inputType);\n      b = this.b.build(builder, bl === 1 ? 'f' : inputType);\n      break;\n    // 3 inputs\n\n    case MathNode.REFRACT:\n      a = this.a.build(builder, inputType);\n      b = this.b.build(builder, inputType);\n      c = this.c.build(builder, 'f');\n      break;\n    case MathNode.MIX:\n      a = this.a.build(builder, inputType);\n      b = this.b.build(builder, inputType);\n      c = this.c.build(builder, cl === 1 ? 'f' : inputType);\n      break;\n    // default\n\n    default:\n      a = this.a.build(builder, inputType);\n      if (this.b) b = this.b.build(builder, inputType);\n      if (this.c) c = this.c.build(builder, inputType);\n      break;\n  } // build function call\n\n  var params = [];\n  params.push(a);\n  if (b) params.push(b);\n  if (c) params.push(c);\n  var numInputs = this.getNumInputs(builder);\n  if (params.length !== numInputs) {\n    throw Error(\"Arguments not match used in \\\"\".concat(this.method, \"\\\". Require \").concat(numInputs, \", currently \").concat(params.length, \".\"));\n  }\n  return builder.format(this.method + '( ' + params.join(', ') + ' )', nodeType, output);\n};\nMathNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.a = source.a;\n  this.b = source.b;\n  this.c = source.c;\n  this.method = source.method;\n  return this;\n};\nMathNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.a = this.a.toJSON(meta).uuid;\n    if (this.b) data.b = this.b.toJSON(meta).uuid;\n    if (this.c) data.c = this.c.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n  return data;\n};\nexport { MathNode };","map":null,"metadata":{},"sourceType":"module"}