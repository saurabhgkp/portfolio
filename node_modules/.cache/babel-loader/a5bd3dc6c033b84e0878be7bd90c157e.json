{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\nReflectNode.prototype.getType = function () /* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n  return this.type;\n};\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n  if (builder.isShader('fragment')) {\n    var result;\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = \"reflect( -normalize( \".concat(viewPosition, \" ), \").concat(viewNormal, \" )\");\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = \"normalize( mix( \".concat(method, \", \").concat(viewNormal, \", \").concat(roughness, \" * \").concat(roughness, \" ) )\");\n        }\n        var code = \"inverseTransformDirection( \".concat(method, \", viewMatrix )\");\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectVec = \".concat(code, \";\"));\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n        break;\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectCubeVec = \".concat(code, \";\"));\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n        break;\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n        if (isUnique) {\n          builder.addNodeCode(\"vec2 reflectSphereVec = \".concat(code, \";\"));\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n        break;\n    }\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n  return data;\n};\nexport { ReflectNode };","map":null,"metadata":{},"sourceType":"module"}