{"ast":null,"code":"import { WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending, Vector2, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\nvar BloomPass = function BloomPass(strength, kernelSize, sigma, resolution) {\n  strength = strength !== undefined ? strength : 1;\n  kernelSize = kernelSize !== undefined ? kernelSize : 25;\n  sigma = sigma !== undefined ? sigma : 4.0;\n  resolution = resolution !== undefined ? resolution : 256; // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetX.texture.name = 'BloomPass.x';\n  this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetY.texture.name = 'BloomPass.y'; // copy material\n\n  if (CopyShader === undefined) console.error('THREE.BloomPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = strength;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    transparent: true\n  }); // convolution material\n\n  if (ConvolutionShader === undefined) console.error('THREE.BloomPass relies on ConvolutionShader');\n  var convolutionShader = ConvolutionShader;\n  this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n  this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n  this.convolutionUniforms['cKernel'].value = ConvolutionShader.buildKernel(sigma);\n  this.materialConvolution = new ShaderMaterial({\n    uniforms: this.convolutionUniforms,\n    vertexShader: convolutionShader.vertexShader,\n    fragmentShader: convolutionShader.fragmentShader,\n    defines: {\n      KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n      KERNEL_SIZE_INT: kernelSize.toFixed(0)\n    }\n  });\n  this.needsSwap = false;\n  this.fsQuad = new FullScreenQuad(null);\n};\nBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: BloomPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)\n\n    this.fsQuad.material = this.materialConvolution;\n    this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n    renderer.setRenderTarget(this.renderTargetX);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)\n\n    this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurY;\n    renderer.setRenderTarget(this.renderTargetY);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetY.texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    this.fsQuad.render(renderer);\n  }\n});\nBloomPass.blurX = new Vector2(0.001953125, 0.0);\nBloomPass.blurY = new Vector2(0.0, 0.001953125);\nexport { BloomPass };","map":null,"metadata":{},"sourceType":"module"}