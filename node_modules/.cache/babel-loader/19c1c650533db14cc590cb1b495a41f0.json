{"ast":null,"code":"import { InputNode } from '../core/InputNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nfunction CubeTextureNode(value, uv, bias) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new ReflectNode();\n  this.bias = bias;\n}\nCubeTextureNode.prototype = Object.create(InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\nCubeTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { CubeTextureNode };","map":null,"metadata":{},"sourceType":"module"}