{"ast":null,"code":"import { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nfunction BasicNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xffffff);\n}\nBasicNode.prototype = Object.create(Node.prototype);\nBasicNode.prototype.constructor = BasicNode;\nBasicNode.prototype.nodeType = 'Basic';\nBasicNode.prototype.generate = function (builder) {\n  var code;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED',\n    // Normal computed with derivatives when FLAT_SHADED\n    ' vNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\n    code = output.join('\\n');\n  } else {\n    // Analyze all nodes to reuse generate codes\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.mask) this.mask.analyze(builder); // Build code\n\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = [\n    // add before: prevent undeclared normal\n    '#include <normal_fragment_begin>', color.code];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', ' if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n    if (alpha) {\n      output.push('gl_FragColor = vec4(' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4(' + color.result + ', 1.0 );');\n    }\n    code = output.join('\\n');\n  }\n  return code;\n};\nBasicNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source);\n  this.color = source.color;\n  if (source.position) this.position = source.position;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.mask) this.mask = source.mask;\n  return this;\n};\nBasicNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.position) data.position = this.position.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { BasicNode };","map":null,"metadata":{},"sourceType":"module"}