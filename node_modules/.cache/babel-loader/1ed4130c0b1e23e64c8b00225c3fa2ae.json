{"ast":null,"code":"import _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/cliffexpc63/my example/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { Vector3, ParametricGeometry, BufferGeometry, Curve } from 'three';\n\n/**\n * Experimenting of primitive geometry creation using Surface Parametric equations\n */\n\nvar ParametricGeometries = {\n  klein: function klein(v, u, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    u = u * 2;\n    var x, y, z;\n    if (u < Math.PI) {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);\n      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\n    } else {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);\n      z = -8 * Math.sin(u);\n    }\n    y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\n    target.set(x, y, z);\n  },\n  plane: function plane(width, height) {\n    return function (u, v, target) {\n      var x = u * width;\n      var y = 0;\n      var z = v * height;\n      target.set(x, y, z);\n    };\n  },\n  mobius: function mobius(u, t, target) {\n    // flat mobius strip\n    // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\n    u = u - 0.5;\n    var v = 2 * Math.PI * t;\n    var x, y, z;\n    var a = 2;\n    x = Math.cos(v) * (a + u * Math.cos(v / 2));\n    y = Math.sin(v) * (a + u * Math.cos(v / 2));\n    z = u * Math.sin(v / 2);\n    target.set(x, y, z);\n  },\n  mobius3d: function mobius3d(u, t, target) {\n    // volumetric mobius strip\n    u *= Math.PI;\n    t *= 2 * Math.PI;\n    u = u * 2;\n    var phi = u / 2;\n    var major = 2.25,\n      a = 0.125,\n      b = 0.65;\n    var x, y, z;\n    x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\n    z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\n    y = (major + x) * Math.sin(u);\n    x = (major + x) * Math.cos(u);\n    target.set(x, y, z);\n  }\n};\n/*********************************************\n *\n * Parametric Replacement for TubeGeometry\n *\n *********************************************/\n\nParametricGeometries.TubeGeometry = function (path, segments, radius, segmentsRadius, closed) {\n  this.path = path;\n  this.segments = segments || 64;\n  this.radius = radius || 1;\n  this.segmentsRadius = segmentsRadius || 8;\n  this.closed = closed || false;\n  var scope = this,\n    numpoints = this.segments + 1;\n  var frames = path.computeFrenetFrames(segments, closed),\n    tangents = frames.tangents,\n    normals = frames.normals,\n    binormals = frames.binormals; // proxy internals\n\n  this.tangents = tangents;\n  this.normals = normals;\n  this.binormals = binormals;\n  var position = new Vector3();\n  var ParametricTube = function ParametricTube(u, v, target) {\n    v *= 2 * Math.PI;\n    var i = u * (numpoints - 1);\n    i = Math.floor(i);\n    path.getPointAt(u, position);\n    var normal = normals[i];\n    var binormal = binormals[i];\n    var cx = -scope.radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n    var cy = scope.radius * Math.sin(v);\n    position.x += cx * normal.x + cy * binormal.x;\n    position.y += cx * normal.y + cy * binormal.y;\n    position.z += cx * normal.z + cy * binormal.z;\n    target.copy(position);\n  };\n  ParametricGeometry.call(this, ParametricTube, segments, segmentsRadius);\n};\nParametricGeometries.TubeGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.TubeGeometry.prototype.constructor = ParametricGeometries.TubeGeometry;\n/*********************************************\n *\n * Parametric Replacement for TorusKnotGeometry\n *\n *********************************************/\n\nParametricGeometries.TorusKnotGeometry = function (radius, tube, segmentsT, segmentsR, p, q) {\n  this.radius = radius || 200;\n  this.tube = tube || 40;\n  this.segmentsT = segmentsT || 64;\n  this.segmentsR = segmentsR || 8;\n  this.p = p || 2;\n  this.q = q || 3;\n  var TorusKnotCurve = /*#__PURE__*/function (_Curve) {\n    _inherits(TorusKnotCurve, _Curve);\n    function TorusKnotCurve() {\n      _classCallCheck(this, TorusKnotCurve);\n      return _possibleConstructorReturn(this, _getPrototypeOf(TorusKnotCurve).call(this));\n    }\n    _createClass(TorusKnotCurve, [{\n      key: \"getPoint\",\n      value: function getPoint(t, optionalTarget) {\n        var point = optionalTarget || new Vector3();\n        t *= Math.PI * 2;\n        var r = 0.5;\n        var x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);\n        var y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);\n        var z = r * Math.sin(q * t);\n        return point.set(x, y, z).multiplyScalar(radius);\n      }\n    }]);\n    return TorusKnotCurve;\n  }(Curve);\n  var segments = segmentsT;\n  var radiusSegments = segmentsR;\n  var extrudePath = new TorusKnotCurve();\n  ParametricGeometries.TubeGeometry.call(this, extrudePath, segments, tube, radiusSegments, true, false);\n};\nParametricGeometries.TorusKnotGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.TorusKnotGeometry.prototype.constructor = ParametricGeometries.TorusKnotGeometry;\n/*********************************************\n *\n * Parametric Replacement for SphereGeometry\n *\n *********************************************/\n\nParametricGeometries.SphereGeometry = function (size, u, v) {\n  function sphere(u, v, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    var x = size * Math.sin(u) * Math.cos(v);\n    var y = size * Math.sin(u) * Math.sin(v);\n    var z = size * Math.cos(u);\n    target.set(x, y, z);\n  }\n  ParametricGeometry.call(this, sphere, u, v);\n};\nParametricGeometries.SphereGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.SphereGeometry.prototype.constructor = ParametricGeometries.SphereGeometry;\n/*********************************************\n *\n * Parametric Replacement for PlaneGeometry\n *\n *********************************************/\n\nParametricGeometries.PlaneGeometry = function (width, depth, segmentsWidth, segmentsDepth) {\n  function plane(u, v, target) {\n    var x = u * width;\n    var y = 0;\n    var z = v * depth;\n    target.set(x, y, z);\n  }\n  ParametricGeometry.call(this, plane, segmentsWidth, segmentsDepth);\n};\nParametricGeometries.PlaneGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.PlaneGeometry.prototype.constructor = ParametricGeometries.PlaneGeometry;\nexport { ParametricGeometries };","map":null,"metadata":{},"sourceType":"module"}