{"ast":null,"code":"import { ShaderMaterial, NormalBlending, FrontSide, NoColors, LessEqualDepth } from 'three';\nimport { NodeBuilder } from '../core/NodeBuilder.js';\nimport { ColorNode } from '../inputs/ColorNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\nimport { RawNode } from './nodes/RawNode.js';\nfunction NodeMaterial(vertex, fragment) {\n  ShaderMaterial.call(this);\n  this.vertex = vertex || new RawNode(new PositionNode(PositionNode.PROJECTION));\n  this.fragment = fragment || new RawNode(new ColorNode(0xff0000));\n  this.updaters = [];\n}\nNodeMaterial.prototype = Object.create(ShaderMaterial.prototype);\nNodeMaterial.prototype.constructor = NodeMaterial;\nNodeMaterial.prototype.type = 'NodeMaterial';\nNodeMaterial.prototype.isNodeMaterial = true;\nObject.defineProperties(NodeMaterial.prototype, {\n  properties: {\n    get: function get() {\n      return this.fragment.properties;\n    }\n  },\n  needsUpdate: {\n    set: function set(value) {\n      if (value === true) this.version++;\n      this.needsCompile = value;\n    },\n    get: function get() {\n      return this.needsCompile;\n    }\n  }\n});\nNodeMaterial.prototype.onBeforeCompile = function (shader, renderer) {\n  this.build({\n    renderer: renderer\n  });\n  shader.defines = this.defines;\n  shader.uniforms = this.uniforms;\n  shader.vertexShader = this.vertexShader;\n  shader.fragmentShader = this.fragmentShader;\n  shader.extensionDerivatives = this.extensions.derivatives === true;\n  shader.extensionFragDepth = this.extensions.fragDepth === true;\n  shader.extensionDrawBuffers = this.extensions.drawBuffers === true;\n  shader.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === true;\n};\nNodeMaterial.prototype.customProgramCacheKey = function () {\n  var hash = this.getHash();\n  return hash;\n};\nNodeMaterial.prototype.getHash = function () {\n  var hash = '{';\n  hash += '\"vertex\":' + this.vertex.getHash() + ',';\n  hash += '\"fragment\":' + this.fragment.getHash();\n  hash += '}';\n  return hash;\n};\nNodeMaterial.prototype.updateFrame = function (frame) {\n  for (var i = 0; i < this.updaters.length; ++i) {\n    frame.updateNode(this.updaters[i]);\n  }\n};\nNodeMaterial.prototype.build = function (params) {\n  params = params || {};\n  var builder = params.builder || new NodeBuilder();\n  builder.setMaterial(this, params.renderer);\n  builder.build(this.vertex, this.fragment);\n  this.vertexShader = builder.getCode('vertex');\n  this.fragmentShader = builder.getCode('fragment');\n  this.defines = builder.defines;\n  this.uniforms = builder.uniforms;\n  this.extensions = builder.extensions;\n  this.updaters = builder.updaters;\n  this.fog = builder.requires.fog;\n  this.lights = builder.requires.lights;\n  this.transparent = builder.requires.transparent || this.blending > NormalBlending;\n  return this;\n};\nNodeMaterial.prototype.copy = function (source) {\n  var uuid = this.uuid;\n  for (var name in source) {\n    this[name] = source[name];\n  }\n  this.uuid = uuid;\n  if (source.userData !== undefined) {\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n  }\n  return this;\n};\nNodeMaterial.prototype.toJSON = function (meta) {\n  var isRootObject = meta === undefined || typeof meta === 'string';\n  if (isRootObject) {\n    meta = {\n      nodes: {}\n    };\n  }\n  if (meta && !meta.materials) meta.materials = {};\n  if (!meta.materials[this.uuid]) {\n    var data = {};\n    data.uuid = this.uuid;\n    data.type = this.type;\n    meta.materials[data.uuid] = data;\n    if (this.name !== '') data.name = this.name;\n    if (this.size !== undefined) data.size = this.size;\n    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.flatShading === true) data.flatShading = this.flatShading;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;\n    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n    if (this.depthTest === false) data.depthTest = this.depthTest;\n    if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n    if (this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n    if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n    if (this.scale !== undefined) data.scale = this.scale;\n    if (this.dithering === true) data.dithering = true;\n    if (this.wireframe === true) data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n    if (this.morphTargets === true) data.morphTargets = true;\n    if (this.skinning === true) data.skinning = true;\n    if (this.visible === false) data.visible = false;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n    data.fog = this.fog;\n    data.lights = this.lights;\n    data.vertex = this.vertex.toJSON(meta).uuid;\n    data.fragment = this.fragment.toJSON(meta).uuid;\n  }\n  meta.material = this.uuid;\n  return meta;\n};\nexport { NodeMaterial };","map":null,"metadata":{},"sourceType":"module"}