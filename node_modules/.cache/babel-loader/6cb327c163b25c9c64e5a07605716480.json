{"ast":null,"code":"import { Ray, Matrix4, Mesh } from 'three';\nimport MeshBVH from './MeshBVH.js';\nimport Visualizer from './MeshBVHVisualizer.js';\nimport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './Constants.js';\nimport { getBVHExtremes, estimateMemoryInBytes } from './Utils/Debug.js';\nimport { MeshBVHDebug } from './MeshBVHDebug.js';\nvar ray = new Ray();\nvar tmpInverseMatrix = new Matrix4();\nvar origMeshRaycastFunc = Mesh.prototype.raycast;\nfunction acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    if (raycaster.firstHitOnly === true) {\n      var res = this.geometry.boundsTree.raycastFirst(this, raycaster, ray);\n      if (res) intersects.push(res);\n    } else {\n      this.geometry.boundsTree.raycast(this, raycaster, ray, intersects);\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nfunction computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nfunction disposeBoundsTree() {\n  this.boundsTree = null;\n}\nexport { MeshBVH, Visualizer, Visualizer as MeshBVHVisualizer, MeshBVHDebug, acceleratedRaycast, computeBoundsTree, disposeBoundsTree, CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED, estimateMemoryInBytes, getBVHExtremes };","map":null,"metadata":{},"sourceType":"module"}