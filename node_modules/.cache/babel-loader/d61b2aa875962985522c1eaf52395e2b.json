{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_1 = require(\"./gast/gast\");\nfunction first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_public_1.NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof gast_public_1.Terminal) {\n    return firstForTerminal(prod);\n  } else if (gast_1.isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (gast_1.isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  var isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return utils_1.uniq(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n  var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;","map":null,"metadata":{},"sourceType":"script"}