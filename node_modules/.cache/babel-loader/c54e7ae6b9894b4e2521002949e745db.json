{"ast":null,"code":"/* Blob.js\n * A Blob, File, FileReader & URL implementation.\n * 2020-02-01\n *\n * By Eli Grey, https://eligrey.com\n * By Jimmy Wärting, https://github.com/jimmywarting\n * License: MIT\n *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md\n */\n\n(function (global) {\n  (function (factory) {\n    if (typeof define === \"function\" && define.amd) {\n      // AMD. Register as an anonymous module.\n      define([\"exports\"], factory);\n    } else if (typeof exports === \"object\" && typeof exports.nodeName !== \"string\") {\n      // CommonJS\n      factory(exports);\n    } else {\n      // Browser globals\n      factory(global);\n    }\n  })(function (exports) {\n    \"use strict\";\n\n    var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;\n    var URL = global.URL || global.webkitURL || function (href, a) {\n      a = document.createElement(\"a\");\n      a.href = href;\n      return a;\n    };\n    var origBlob = global.Blob;\n    var createObjectURL = URL.createObjectURL;\n    var revokeObjectURL = URL.revokeObjectURL;\n    var strTag = global.Symbol && global.Symbol.toStringTag;\n    var blobSupported = false;\n    var blobSupportsArrayBufferView = false;\n    var arrayBufferSupported = !!global.ArrayBuffer;\n    var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;\n    try {\n      // Check if Blob constructor is supported\n      blobSupported = new Blob([\"ä\"]).size === 2;\n\n      // Check if Blob constructor supports ArrayBufferViews\n      // Fails in Safari 6, so we need to map to ArrayBuffers there.\n      blobSupportsArrayBufferView = new Blob([new Uint8Array([1, 2])]).size === 2;\n    } catch (e) {/**/}\n\n    // Helper function that maps ArrayBufferViews to ArrayBuffers\n    // Used by BlobBuilder constructor and old browsers that didn't\n    // support it in the Blob constructor.\n    function mapArrayBufferViews(ary) {\n      return ary.map(function (chunk) {\n        if (chunk.buffer instanceof ArrayBuffer) {\n          var buf = chunk.buffer;\n\n          // if this is a subarray, make a copy so we only\n          // include the subarray region from the underlying buffer\n          if (chunk.byteLength !== buf.byteLength) {\n            var copy = new Uint8Array(chunk.byteLength);\n            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n            buf = copy.buffer;\n          }\n          return buf;\n        }\n        return chunk;\n      });\n    }\n    function BlobBuilderConstructor(ary, options) {\n      options = options || {};\n      var bb = new BlobBuilder();\n      mapArrayBufferViews(ary).forEach(function (part) {\n        bb.append(part);\n      });\n      return options.type ? bb.getBlob(options.type) : bb.getBlob();\n    }\n    function BlobConstructor(ary, options) {\n      return new origBlob(mapArrayBufferViews(ary), options || {});\n    }\n    if (global.Blob) {\n      BlobBuilderConstructor.prototype = Blob.prototype;\n      BlobConstructor.prototype = Blob.prototype;\n    }\n\n    /********************************************************/\n    /*               String Encoder fallback                */\n    /********************************************************/\n    function stringEncode(string) {\n      var pos = 0;\n      var len = string.length;\n      var Arr = global.Uint8Array || Array; // Use byte array when possible\n\n      var at = 0; // output position\n      var tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n      var target = new Arr(tlen >> 3 << 3); // ... but at 8 byte offset\n\n      while (pos < len) {\n        var value = string.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff) {\n          // high surrogate\n          if (pos < len) {\n            var extra = string.charCodeAt(pos);\n            if ((extra & 0xfc00) === 0xdc00) {\n              ++pos;\n              value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n            }\n          }\n          if (value >= 0xd800 && value <= 0xdbff) {\n            continue; // drop lone surrogate\n          }\n        }\n\n        // expand the buffer if we couldn't write 4 bytes\n        if (at + 4 > target.length) {\n          tlen += 8; // minimum extra\n          tlen *= 1.0 + pos / string.length * 2; // take 2x the remaining\n          tlen = tlen >> 3 << 3; // 8 byte offset\n\n          var update = new Uint8Array(tlen);\n          update.set(target);\n          target = update;\n        }\n        if ((value & 0xffffff80) === 0) {\n          // 1-byte\n          target[at++] = value; // ASCII\n          continue;\n        } else if ((value & 0xfffff800) === 0) {\n          // 2-byte\n          target[at++] = value >> 6 & 0x1f | 0xc0;\n        } else if ((value & 0xffff0000) === 0) {\n          // 3-byte\n          target[at++] = value >> 12 & 0x0f | 0xe0;\n          target[at++] = value >> 6 & 0x3f | 0x80;\n        } else if ((value & 0xffe00000) === 0) {\n          // 4-byte\n          target[at++] = value >> 18 & 0x07 | 0xf0;\n          target[at++] = value >> 12 & 0x3f | 0x80;\n          target[at++] = value >> 6 & 0x3f | 0x80;\n        } else {\n          // FIXME: do we care\n          continue;\n        }\n        target[at++] = value & 0x3f | 0x80;\n      }\n      return target.slice(0, at);\n    }\n\n    /********************************************************/\n    /*               String Decoder fallback                */\n    /********************************************************/\n    function stringDecode(buf) {\n      var end = buf.length;\n      var res = [];\n      var i = 0;\n      while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          var secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 0x80) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                if (tempCodePoint > 0x7F) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          // we did not generate a valid codePoint so insert a\n          // replacement char (U+FFFD) and advance only 1 byte\n          codePoint = 0xFFFD;\n          bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n          // encode to utf16 (surrogate pair dance)\n          codePoint -= 0x10000;\n          res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n          codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      var len = res.length;\n      var str = \"\";\n      var j = 0;\n      while (j < len) {\n        str += String.fromCharCode.apply(String, res.slice(j, j += 0x1000));\n      }\n      return str;\n    }\n\n    // string -> buffer\n    var textEncode = typeof TextEncoder === \"function\" ? TextEncoder.prototype.encode.bind(new TextEncoder()) : stringEncode;\n\n    // buffer -> string\n    var textDecode = typeof TextDecoder === \"function\" ? TextDecoder.prototype.decode.bind(new TextDecoder()) : stringDecode;\n    function FakeBlobBuilder() {\n      function isDataView(obj) {\n        return obj && Object.prototype.isPrototypeOf.call(DataView, obj);\n      }\n      function bufferClone(buf) {\n        var view = new Array(buf.byteLength);\n        var array = new Uint8Array(buf);\n        var i = view.length;\n        while (i--) {\n          view[i] = array[i];\n        }\n        return view;\n      }\n      function array2base64(input) {\n        var byteToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        var output = [];\n        for (var i = 0; i < input.length; i += 3) {\n          var byte1 = input[i];\n          var haveByte2 = i + 1 < input.length;\n          var byte2 = haveByte2 ? input[i + 1] : 0;\n          var haveByte3 = i + 2 < input.length;\n          var byte3 = haveByte3 ? input[i + 2] : 0;\n          var outByte1 = byte1 >> 2;\n          var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n          var outByte3 = (byte2 & 0x0F) << 2 | byte3 >> 6;\n          var outByte4 = byte3 & 0x3F;\n          if (!haveByte3) {\n            outByte4 = 64;\n            if (!haveByte2) {\n              outByte3 = 64;\n            }\n          }\n          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n      }\n      var create = Object.create || function (a) {\n        function c() {}\n        c.prototype = a;\n        return new c();\n      };\n      if (arrayBufferSupported) {\n        var viewClasses = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"];\n        var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n        };\n      }\n      function concatTypedarrays(chunks) {\n        var size = 0;\n        var j = chunks.length;\n        while (j--) {\n          size += chunks[j].length;\n        }\n        var b = new Uint8Array(size);\n        var offset = 0;\n        for (var i = 0; i < chunks.length; i++) {\n          var chunk = chunks[i];\n          b.set(chunk, offset);\n          offset += chunk.byteLength || chunk.length;\n        }\n        return b;\n      }\n\n      /********************************************************/\n      /*                   Blob constructor                   */\n      /********************************************************/\n      function Blob(chunks, opts) {\n        chunks = chunks || [];\n        opts = opts == null ? {} : opts;\n        for (var i = 0, len = chunks.length; i < len; i++) {\n          var chunk = chunks[i];\n          if (chunk instanceof Blob) {\n            chunks[i] = chunk._buffer;\n          } else if (typeof chunk === \"string\") {\n            chunks[i] = textEncode(chunk);\n          } else if (arrayBufferSupported && (Object.prototype.isPrototypeOf.call(ArrayBuffer, chunk) || isArrayBufferView(chunk))) {\n            chunks[i] = bufferClone(chunk);\n          } else if (arrayBufferSupported && isDataView(chunk)) {\n            chunks[i] = bufferClone(chunk.buffer);\n          } else {\n            chunks[i] = textEncode(String(chunk));\n          }\n        }\n        this._buffer = global.Uint8Array ? concatTypedarrays(chunks) : [].concat.apply([], chunks);\n        this.size = this._buffer.length;\n        this.type = opts.type || \"\";\n        if (/[^\\u0020-\\u007E]/.test(this.type)) {\n          this.type = \"\";\n        } else {\n          this.type = this.type.toLowerCase();\n        }\n      }\n      Blob.prototype.arrayBuffer = function () {\n        return Promise.resolve(this._buffer.buffer || this._buffer);\n      };\n      Blob.prototype.text = function () {\n        return Promise.resolve(textDecode(this._buffer));\n      };\n      Blob.prototype.slice = function (start, end, type) {\n        var slice = this._buffer.slice(start || 0, end || this._buffer.length);\n        return new Blob([slice], {\n          type: type\n        });\n      };\n      Blob.prototype.toString = function () {\n        return \"[object Blob]\";\n      };\n\n      /********************************************************/\n      /*                   File constructor                   */\n      /********************************************************/\n      function File(chunks, name, opts) {\n        opts = opts || {};\n        var a = Blob.call(this, chunks, opts) || this;\n        a.name = name.replace(/\\//g, \":\");\n        a.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\n        a.lastModified = +a.lastModifiedDate;\n        return a;\n      }\n      File.prototype = create(Blob.prototype);\n      File.prototype.constructor = File;\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(File, Blob);\n      } else {\n        try {\n          File.__proto__ = Blob;\n        } catch (e) {/**/}\n      }\n      File.prototype.toString = function () {\n        return \"[object File]\";\n      };\n\n      /********************************************************/\n      /*                FileReader constructor                */\n      /********************************************************/\n      function FileReader() {\n        if (!(this instanceof FileReader)) {\n          throw new TypeError(\"Failed to construct 'FileReader': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n        }\n        var delegate = document.createDocumentFragment();\n        this.addEventListener = delegate.addEventListener;\n        this.dispatchEvent = function (evt) {\n          var local = this[\"on\" + evt.type];\n          if (typeof local === \"function\") local(evt);\n          delegate.dispatchEvent(evt);\n        };\n        this.removeEventListener = delegate.removeEventListener;\n      }\n      function _read(fr, blob, kind) {\n        if (!(blob instanceof Blob)) {\n          throw new TypeError(\"Failed to execute '\" + kind + \"' on 'FileReader': parameter 1 is not of type 'Blob'.\");\n        }\n        fr.result = \"\";\n        setTimeout(function () {\n          this.readyState = FileReader.LOADING;\n          fr.dispatchEvent(new Event(\"load\"));\n          fr.dispatchEvent(new Event(\"loadend\"));\n        });\n      }\n      FileReader.EMPTY = 0;\n      FileReader.LOADING = 1;\n      FileReader.DONE = 2;\n      FileReader.prototype.error = null;\n      FileReader.prototype.onabort = null;\n      FileReader.prototype.onerror = null;\n      FileReader.prototype.onload = null;\n      FileReader.prototype.onloadend = null;\n      FileReader.prototype.onloadstart = null;\n      FileReader.prototype.onprogress = null;\n      FileReader.prototype.readAsDataURL = function (blob) {\n        _read(this, blob, \"readAsDataURL\");\n        this.result = \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer);\n      };\n      FileReader.prototype.readAsText = function (blob) {\n        _read(this, blob, \"readAsText\");\n        this.result = textDecode(blob._buffer);\n      };\n      FileReader.prototype.readAsArrayBuffer = function (blob) {\n        _read(this, blob, \"readAsText\");\n        // return ArrayBuffer when possible\n        this.result = (blob._buffer.buffer || blob._buffer).slice();\n      };\n      FileReader.prototype.abort = function () {};\n\n      /********************************************************/\n      /*                         URL                          */\n      /********************************************************/\n      URL.createObjectURL = function (blob) {\n        return blob instanceof Blob ? \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer) : createObjectURL.call(URL, blob);\n      };\n      URL.revokeObjectURL = function (url) {\n        revokeObjectURL && revokeObjectURL.call(URL, url);\n      };\n\n      /********************************************************/\n      /*                         XHR                          */\n      /********************************************************/\n      var _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n      if (_send) {\n        XMLHttpRequest.prototype.send = function (data) {\n          if (data instanceof Blob) {\n            this.setRequestHeader(\"Content-Type\", data.type);\n            _send.call(this, textDecode(data._buffer));\n          } else {\n            _send.call(this, data);\n          }\n        };\n      }\n      exports.Blob = Blob;\n      exports.File = File;\n      exports.FileReader = FileReader;\n      exports.URL = URL;\n    }\n    function fixFileAndXHR() {\n      var isIE = !!global.ActiveXObject || \"-ms-scroll-limit\" in document.documentElement.style && \"-ms-ime-align\" in document.documentElement.style;\n\n      // Monkey patched\n      // IE doesn't set Content-Type header on XHR whose body is a typed Blob\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/6047383\n      var _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n      if (isIE && _send) {\n        XMLHttpRequest.prototype.send = function (data) {\n          if (data instanceof Blob) {\n            this.setRequestHeader(\"Content-Type\", data.type);\n            _send.call(this, data);\n          } else {\n            _send.call(this, data);\n          }\n        };\n      }\n      try {\n        new File([], \"\");\n        exports.File = global.File;\n        exports.FileReader = global.FileReader;\n      } catch (e) {\n        try {\n          exports.File = new Function(\"class File extends Blob {\" + \"constructor(chunks, name, opts) {\" + \"opts = opts || {};\" + \"super(chunks, opts || {});\" + \"this.name = name.replace(/\\\\//g, \\\":\\\");\" + \"this.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\" + \"this.lastModified = +this.lastModifiedDate;\" + \"}};\" + \"return new File([], \\\"\\\"), File\")();\n        } catch (e) {\n          exports.File = function (b, d, c) {\n            var blob = new Blob(b, c);\n            var t = c && void 0 !== c.lastModified ? new Date(c.lastModified) : new Date();\n            blob.name = d.replace(/\\//g, \":\");\n            blob.lastModifiedDate = t;\n            blob.lastModified = +t;\n            blob.toString = function () {\n              return \"[object File]\";\n            };\n            if (strTag) {\n              blob[strTag] = \"File\";\n            }\n            return blob;\n          };\n        }\n      }\n    }\n    if (blobSupported) {\n      fixFileAndXHR();\n      exports.Blob = blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n    } else if (blobBuilderSupported) {\n      fixFileAndXHR();\n      exports.Blob = BlobBuilderConstructor;\n    } else {\n      FakeBlobBuilder();\n    }\n    if (strTag) {\n      if (!exports.File.prototype[strTag]) exports.File.prototype[strTag] = \"File\";\n      if (!exports.Blob.prototype[strTag]) exports.Blob.prototype[strTag] = \"Blob\";\n      if (!exports.FileReader.prototype[strTag]) exports.FileReader.prototype[strTag] = \"FileReader\";\n    }\n    var blob = exports.Blob.prototype;\n    var stream;\n    try {\n      new ReadableStream({\n        type: \"bytes\"\n      });\n      stream = function stream() {\n        var position = 0;\n        var blob = this;\n        return new ReadableStream({\n          type: \"bytes\",\n          autoAllocateChunkSize: 524288,\n          pull: function pull(controller) {\n            var v = controller.byobRequest.view;\n            var chunk = blob.slice(position, position + v.byteLength);\n            return chunk.arrayBuffer().then(function (buffer) {\n              var uint8array = new Uint8Array(buffer);\n              var bytesRead = uint8array.byteLength;\n              position += bytesRead;\n              v.set(uint8array);\n              controller.byobRequest.respond(bytesRead);\n              if (position >= blob.size) controller.close();\n            });\n          }\n        });\n      };\n    } catch (e) {\n      try {\n        new ReadableStream({});\n        stream = function stream(blob) {\n          var position = 0;\n          return new ReadableStream({\n            pull: function pull(controller) {\n              var chunk = blob.slice(position, position + 524288);\n              return chunk.arrayBuffer().then(function (buffer) {\n                position += buffer.byteLength;\n                var uint8array = new Uint8Array(buffer);\n                controller.enqueue(uint8array);\n                if (position == blob.size) controller.close();\n              });\n            }\n          });\n        };\n      } catch (e) {\n        try {\n          new Response(\"\").body.getReader().read();\n          stream = function stream() {\n            return new Response(this).body;\n          };\n        } catch (e) {\n          stream = function stream() {\n            throw new Error(\"Include https://github.com/MattiasBuelens/web-streams-polyfill\");\n          };\n        }\n      }\n    }\n    function promisify(obj) {\n      return new Promise(function (resolve, reject) {\n        obj.onload = obj.onerror = function (evt) {\n          obj.onload = obj.onerror = null;\n          evt.type === \"load\" ? resolve(obj.result || obj) : reject(new Error(\"Failed to read the blob/file\"));\n        };\n      });\n    }\n    if (!blob.arrayBuffer) {\n      blob.arrayBuffer = function arrayBuffer() {\n        var fr = new FileReader();\n        fr.readAsArrayBuffer(this);\n        return promisify(fr);\n      };\n    }\n    if (!blob.text) {\n      blob.text = function text() {\n        var fr = new FileReader();\n        fr.readAsText(this);\n        return promisify(fr);\n      };\n    }\n    if (!blob.stream) {\n      blob.stream = stream;\n    }\n  });\n})(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || this);","map":null,"metadata":{},"sourceType":"script"}