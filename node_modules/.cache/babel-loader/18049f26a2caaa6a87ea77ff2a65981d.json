{"ast":null,"code":"import { MathUtils } from 'three';\nfunction Node(type) {\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = type;\n  this.userData = {};\n}\nNode.prototype = {\n  constructor: Node,\n  isNode: true,\n  hashProperties: undefined,\n  analyze: function analyze(builder, settings) {\n    settings = settings || {};\n    builder.analyzing = true;\n    this.build(builder.addFlow(settings.slot, settings.cache, settings.context), 'v4');\n    builder.clearVertexNodeCode();\n    builder.clearFragmentNodeCode();\n    builder.removeFlow();\n    builder.analyzing = false;\n  },\n  analyzeAndFlow: function analyzeAndFlow(builder, output, settings) {\n    settings = settings || {};\n    this.analyze(builder, settings);\n    return this.flow(builder, output, settings);\n  },\n  flow: function flow(builder, output, settings) {\n    settings = settings || {};\n    builder.addFlow(settings.slot, settings.cache, settings.context);\n    var flow = {};\n    flow.result = this.build(builder, output);\n    flow.code = builder.clearNodeCode();\n    flow.extra = builder.context.extra;\n    builder.removeFlow();\n    return flow;\n  },\n  build: function build(builder, output, uuid) {\n    output = output || this.getType(builder, output);\n    var data = builder.getNodeData(uuid || this);\n    if (builder.analyzing) {\n      this.appendDepsNode(builder, data, output);\n    }\n    if (builder.nodes.indexOf(this) === -1) {\n      builder.nodes.push(this);\n    }\n    if (this.updateFrame !== undefined && builder.updaters.indexOf(this) === -1) {\n      builder.updaters.push(this);\n    }\n    return this.generate(builder, output, uuid);\n  },\n  generate: function generate() /* builder, output, uuid, type, ns */\n  {// This method needs to be implemented in subclasses\n  },\n  getHash: function getHash() {\n    var hash = '{';\n    var prop, obj;\n    for (prop in this) {\n      obj = this[prop];\n      if (obj instanceof Node) {\n        hash += '\"' + prop + '\":' + obj.getHash() + ',';\n      }\n    }\n    if (this.hashProperties) {\n      for (var i = 0; i < this.hashProperties.length; i++) {\n        prop = this.hashProperties[i];\n        obj = this[prop];\n        hash += '\"' + prop + '\":\"' + String(obj) + '\",';\n      }\n    }\n    hash += '\"id\":\"' + this.uuid + '\"}';\n    return hash;\n  },\n  appendDepsNode: function appendDepsNode(builder, data, output) {\n    data.deps = (data.deps || 0) + 1;\n    var outputLen = builder.getTypeLength(output);\n    if (outputLen > (data.outputMax || 0) || this.getType(builder, output)) {\n      data.outputMax = outputLen;\n      data.output = output;\n    }\n  },\n  setName: function setName(name) {\n    this.name = name;\n    return this;\n  },\n  getName: function getName() /* builder */\n  {\n    return this.name;\n  },\n  getType: function getType(builder, output) {\n    return output === 'sampler2D' || output === 'samplerCube' ? output : this.type;\n  },\n  getJSONNode: function getJSONNode(meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n    if (!isRootObject && meta.nodes[this.uuid] !== undefined) {\n      return meta.nodes[this.uuid];\n    }\n  },\n  copy: function copy(source) {\n    if (source.name !== undefined) this.name = source.name;\n    if (source.userData !== undefined) this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  },\n  createJSONNode: function createJSONNode(meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n    var data = {};\n    if (typeof this.nodeType !== 'string') throw new Error('Node does not allow serialization.');\n    data.uuid = this.uuid;\n    data.nodeType = this.nodeType;\n    if (this.name !== '') data.name = this.name;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n    if (!isRootObject) {\n      meta.nodes[this.uuid] = data;\n    }\n    return data;\n  },\n  toJSON: function toJSON(meta) {\n    return this.getJSONNode(meta) || this.createJSONNode(meta);\n  }\n};\nexport { Node };","map":null,"metadata":{},"sourceType":"module"}