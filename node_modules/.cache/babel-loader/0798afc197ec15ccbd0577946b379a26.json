{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar AbstractProduction = /** @class */function () {\n  function AbstractProduction(_definition) {\n    this._definition = _definition;\n  }\n  Object.defineProperty(AbstractProduction.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractProduction.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    utils_1.forEach(this.definition, function (prod) {\n      prod.accept(visitor);\n    });\n  };\n  return AbstractProduction;\n}();\nexports.AbstractProduction = AbstractProduction;\nvar NonTerminal = /** @class */function (_super) {\n  __extends(NonTerminal, _super);\n  function NonTerminal(options) {\n    var _this = _super.call(this, []) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  Object.defineProperty(NonTerminal.prototype, \"definition\", {\n    get: function get() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition;\n      }\n      return [];\n    },\n    set: function set(definition) {\n      // immutable\n    },\n    enumerable: false,\n    configurable: true\n  });\n  NonTerminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  };\n\n  return NonTerminal;\n}(AbstractProduction);\nexports.NonTerminal = NonTerminal;\nvar Rule = /** @class */function (_super) {\n  __extends(Rule, _super);\n  function Rule(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.orgText = \"\";\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Rule;\n}(AbstractProduction);\nexports.Rule = Rule;\nvar Alternative = /** @class */function (_super) {\n  __extends(Alternative, _super);\n  function Alternative(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.ignoreAmbiguities = false;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Alternative;\n}(AbstractProduction);\nexports.Alternative = Alternative;\nvar Option = /** @class */function (_super) {\n  __extends(Option, _super);\n  function Option(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Option;\n}(AbstractProduction);\nexports.Option = Option;\nvar RepetitionMandatory = /** @class */function (_super) {\n  __extends(RepetitionMandatory, _super);\n  function RepetitionMandatory(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatory;\n}(AbstractProduction);\nexports.RepetitionMandatory = RepetitionMandatory;\nvar RepetitionMandatoryWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionMandatoryWithSeparator, _super);\n  function RepetitionMandatoryWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatoryWithSeparator;\n}(AbstractProduction);\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\nvar Repetition = /** @class */function (_super) {\n  __extends(Repetition, _super);\n  function Repetition(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Repetition;\n}(AbstractProduction);\nexports.Repetition = Repetition;\nvar RepetitionWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionWithSeparator, _super);\n  function RepetitionWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionWithSeparator;\n}(AbstractProduction);\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\nvar Alternation = /** @class */function (_super) {\n  __extends(Alternation, _super);\n  function Alternation(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    _this.ignoreAmbiguities = false;\n    _this.hasPredicates = false;\n    utils_1.assign(_this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  Object.defineProperty(Alternation.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Alternation;\n}(AbstractProduction);\nexports.Alternation = Alternation;\nvar Terminal = /** @class */function () {\n  function Terminal(options) {\n    this.idx = 1;\n    utils_1.assign(this, utils_1.pick(options, function (v) {\n      return v !== undefined;\n    }));\n  }\n  Terminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n  };\n  return Terminal;\n}();\nexports.Terminal = Terminal;\nfunction serializeGrammar(topRules) {\n  return utils_1.map(topRules, serializeProduction);\n}\nexports.serializeGrammar = serializeGrammar;\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return utils_1.map(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    var serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n    if (utils_1.isString(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    var serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokens_public_1.tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n    if (utils_1.isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n    var pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = utils_1.isRegExp(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.serializeProduction = serializeProduction;","map":null,"metadata":{},"sourceType":"script"}