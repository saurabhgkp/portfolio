{"ast":null,"code":"import { CubeUVRefractionMapping, CubeUVReflectionMapping, CubeRefractionMapping, CubeReflectionMapping, LinearEncoding, GammaEncoding } from 'three';\nimport { NodeUniform } from './NodeUniform.js';\nimport { NodeUtils } from './NodeUtils.js';\nimport { NodeLib } from './NodeLib.js';\nimport { FunctionNode } from './FunctionNode.js';\nimport { ConstNode } from './ConstNode.js';\nimport { StructNode } from './StructNode.js';\nimport { Vector2Node } from '../inputs/Vector2Node.js';\nimport { Vector3Node } from '../inputs/Vector3Node.js';\nimport { Vector4Node } from '../inputs/Vector4Node.js';\nimport { TextureNode } from '../inputs/TextureNode.js';\nimport { CubeTextureNode } from '../inputs/CubeTextureNode.js';\nimport { TextureCubeNode } from '../misc/TextureCubeNode.js';\nvar elements = NodeUtils.elements,\n  constructors = ['float', 'vec2', 'vec3', 'vec4'],\n  convertFormatToType = {\n    float: 'f',\n    vec2: 'v2',\n    vec3: 'v3',\n    vec4: 'v4',\n    mat4: 'v4',\n    int: 'i',\n    bool: 'b'\n  },\n  convertTypeToFormat = {\n    t: 'sampler2D',\n    tc: 'samplerCube',\n    b: 'bool',\n    i: 'int',\n    f: 'float',\n    c: 'vec3',\n    v2: 'vec2',\n    v3: 'vec3',\n    v4: 'vec4',\n    m3: 'mat3',\n    m4: 'mat4'\n  };\nfunction NodeBuilder() {\n  this.slots = [];\n  this.caches = [];\n  this.contexts = [];\n  this.keywords = {};\n  this.nodeData = {};\n  this.requires = {\n    uv: [],\n    color: [],\n    lights: false,\n    fog: false,\n    transparent: false,\n    irradiance: false\n  };\n  this.includes = {\n    consts: [],\n    functions: [],\n    structs: []\n  };\n  this.attributes = {};\n  this.prefixCode = ['#ifdef TEXTURE_LOD_EXT', '\t#define texCube(a, b) textureCube(a, b)', '\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)', '\t#define tex2D(a, b) texture2D(a, b)', '\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)', '#else', '\t#define texCube(a, b) textureCube(a, b)', '\t#define texCubeBias(a, b, c) textureCube(a, b, c)', '\t#define tex2D(a, b) texture2D(a, b)', '\t#define tex2DBias(a, b, c) texture2D(a, b, c)', '#endif', '#include <packing>', '#include <common>'].join('\\n');\n  this.parsCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.code = {\n    vertex: '',\n    fragment: ''\n  };\n  this.nodeCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.resultCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.finalCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.inputs = {\n    uniforms: {\n      list: [],\n      vertex: [],\n      fragment: []\n    },\n    vars: {\n      varying: [],\n      vertex: [],\n      fragment: []\n    }\n  }; // send to material\n\n  this.defines = {};\n  this.uniforms = {};\n  this.extensions = {};\n  this.updaters = [];\n  this.nodes = []; // --\n\n  this.analyzing = false;\n}\nNodeBuilder.prototype = {\n  constructor: NodeBuilder,\n  build: function build(vertex, fragment) {\n    this.buildShader('vertex', vertex);\n    this.buildShader('fragment', fragment);\n    for (var i = 0; i < this.requires.uv.length; i++) {\n      if (this.requires.uv[i]) {\n        var uvIndex = i > 0 ? i + 1 : '';\n        this.addVaryCode('varying vec2 vUv' + uvIndex + ';');\n        if (i > 0) {\n          this.addVertexParsCode('attribute vec2 uv' + uvIndex + ';');\n        }\n        this.addVertexFinalCode('vUv' + uvIndex + ' = uv' + uvIndex + ';');\n      }\n    }\n    if (this.requires.color[0]) {\n      this.addVaryCode('varying vec4 vColor;');\n      this.addVertexParsCode('attribute vec4 color;');\n      this.addVertexFinalCode('vColor = color;');\n    }\n    if (this.requires.color[1]) {\n      this.addVaryCode('varying vec4 vColor2;');\n      this.addVertexParsCode('attribute vec4 color2;');\n      this.addVertexFinalCode('vColor2 = color2;');\n    }\n    if (this.requires.position) {\n      this.addVaryCode('varying vec3 vPosition;');\n      this.addVertexFinalCode('vPosition = transformed;');\n    }\n    if (this.requires.worldPosition) {\n      this.addVaryCode('varying vec3 vWPosition;');\n      this.addVertexFinalCode('vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;');\n    }\n    if (this.requires.normal) {\n      this.addVaryCode('varying vec3 vObjectNormal;');\n      this.addVertexFinalCode('vObjectNormal = normal;');\n    }\n    if (this.requires.worldNormal) {\n      this.addVaryCode('varying vec3 vWNormal;');\n      this.addVertexFinalCode('vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;');\n    }\n    return this;\n  },\n  buildShader: function buildShader(shader, node) {\n    this.resultCode[shader] = node.build(this.setShader(shader), 'v4');\n  },\n  setMaterial: function setMaterial(material, renderer) {\n    this.material = material;\n    this.renderer = renderer;\n    this.requires.lights = material.lights;\n    this.requires.fog = material.fog;\n    this.mergeDefines(material.defines);\n    return this;\n  },\n  addFlow: function addFlow(slot, cache, context) {\n    return this.addSlot(slot).addCache(cache).addContext(context);\n  },\n  removeFlow: function removeFlow() {\n    return this.removeSlot().removeCache().removeContext();\n  },\n  addCache: function addCache(name) {\n    this.cache = name || '';\n    this.caches.push(this.cache);\n    return this;\n  },\n  removeCache: function removeCache() {\n    this.caches.pop();\n    this.cache = this.caches[this.caches.length - 1] || '';\n    return this;\n  },\n  addContext: function addContext(context) {\n    this.context = Object.assign({}, this.context, context);\n    this.context.extra = this.context.extra || {};\n    this.contexts.push(this.context);\n    return this;\n  },\n  removeContext: function removeContext() {\n    this.contexts.pop();\n    this.context = this.contexts[this.contexts.length - 1] || {};\n    return this;\n  },\n  addSlot: function addSlot(name) {\n    this.slot = name || '';\n    this.slots.push(this.slot);\n    return this;\n  },\n  removeSlot: function removeSlot() {\n    this.slots.pop();\n    this.slot = this.slots[this.slots.length - 1] || '';\n    return this;\n  },\n  addVertexCode: function addVertexCode(code) {\n    this.addCode(code, 'vertex');\n  },\n  addFragmentCode: function addFragmentCode(code) {\n    this.addCode(code, 'fragment');\n  },\n  addCode: function addCode(code, shader) {\n    this.code[shader || this.shader] += code + '\\n';\n  },\n  addVertexNodeCode: function addVertexNodeCode(code) {\n    this.addNodeCode(code, 'vertex');\n  },\n  addFragmentNodeCode: function addFragmentNodeCode(code) {\n    this.addNodeCode(code, 'fragment');\n  },\n  addNodeCode: function addNodeCode(code, shader) {\n    this.nodeCode[shader || this.shader] += code + '\\n';\n  },\n  clearNodeCode: function clearNodeCode(shader) {\n    shader = shader || this.shader;\n    var code = this.nodeCode[shader];\n    this.nodeCode[shader] = '';\n    return code;\n  },\n  clearVertexNodeCode: function clearVertexNodeCode() {\n    return this.clearNodeCode('vertex');\n  },\n  clearFragmentNodeCode: function clearFragmentNodeCode() {\n    return this.clearNodeCode('fragment');\n  },\n  addVertexFinalCode: function addVertexFinalCode(code) {\n    this.addFinalCode(code, 'vertex');\n  },\n  addFragmentFinalCode: function addFragmentFinalCode(code) {\n    this.addFinalCode(code, 'fragment');\n  },\n  addFinalCode: function addFinalCode(code, shader) {\n    this.finalCode[shader || this.shader] += code + '\\n';\n  },\n  addVertexParsCode: function addVertexParsCode(code) {\n    this.addParsCode(code, 'vertex');\n  },\n  addFragmentParsCode: function addFragmentParsCode(code) {\n    this.addParsCode(code, 'fragment');\n  },\n  addParsCode: function addParsCode(code, shader) {\n    this.parsCode[shader || this.shader] += code + '\\n';\n  },\n  addVaryCode: function addVaryCode(code) {\n    this.addVertexParsCode(code);\n    this.addFragmentParsCode(code);\n  },\n  isCache: function isCache(name) {\n    return this.caches.indexOf(name) !== -1;\n  },\n  isSlot: function isSlot(name) {\n    return this.slots.indexOf(name) !== -1;\n  },\n  define: function define(name, value) {\n    this.defines[name] = value === undefined ? 1 : value;\n  },\n  require: function require(name) {\n    this.requires[name] = true;\n  },\n  isDefined: function isDefined(name) {\n    return this.defines[name] !== undefined;\n  },\n  getVar: function getVar(uuid, type, ns) {\n    var shader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'varying';\n    var prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'V';\n    var label = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';\n    var vars = this.getVars(shader),\n      data = vars[uuid];\n    if (!data) {\n      var index = vars.length,\n        name = ns ? ns : 'node' + prefix + index + (label ? '_' + label : '');\n      data = {\n        name: name,\n        type: type\n      };\n      vars.push(data);\n      vars[uuid] = data;\n    }\n    return data;\n  },\n  getTempVar: function getTempVar(uuid, type, ns, label) {\n    return this.getVar(uuid, type, ns, this.shader, 'T', label);\n  },\n  getAttribute: function getAttribute(name, type) {\n    if (!this.attributes[name]) {\n      var varying = this.getVar(name, type);\n      this.addVertexParsCode('attribute ' + type + ' ' + name + ';');\n      this.addVertexFinalCode(varying.name + ' = ' + name + ';');\n      this.attributes[name] = {\n        varying: varying,\n        name: name,\n        type: type\n      };\n    }\n    return this.attributes[name];\n  },\n  getCode: function getCode(shader) {\n    return [this.prefixCode, this.parsCode[shader], this.getVarListCode(this.getVars('varying'), 'varying'), this.getVarListCode(this.inputs.uniforms[shader], 'uniform'), this.getIncludesCode('consts', shader), this.getIncludesCode('structs', shader), this.getIncludesCode('functions', shader), 'void main() {', this.getVarListCode(this.getVars(shader)), this.code[shader], this.resultCode[shader], this.finalCode[shader], '}'].join('\\n');\n  },\n  getVarListCode: function getVarListCode(vars, prefix) {\n    prefix = prefix || '';\n    var code = '';\n    for (var i = 0, l = vars.length; i < l; ++i) {\n      var nVar = vars[i],\n        type = nVar.type,\n        name = nVar.name;\n      var formatType = this.getFormatByType(type);\n      if (formatType === undefined) {\n        throw new Error('Node pars ' + formatType + ' not found.');\n      }\n      code += prefix + ' ' + formatType + ' ' + name + ';\\n';\n    }\n    return code;\n  },\n  getVars: function getVars(shader) {\n    return this.inputs.vars[shader || this.shader];\n  },\n  getNodeData: function getNodeData(node) {\n    var uuid = node.isNode ? node.uuid : node;\n    return this.nodeData[uuid] = this.nodeData[uuid] || {};\n  },\n  createUniform: function createUniform(shader, type, node, ns, needsUpdate, label) {\n    var uniforms = this.inputs.uniforms,\n      index = uniforms.list.length;\n    var uniform = new NodeUniform({\n      type: type,\n      name: ns ? ns : 'nodeU' + index + (label ? '_' + label : ''),\n      node: node,\n      needsUpdate: needsUpdate\n    });\n    uniforms.list.push(uniform);\n    uniforms[shader].push(uniform);\n    uniforms[shader][uniform.name] = uniform;\n    this.uniforms[uniform.name] = uniform;\n    return uniform;\n  },\n  createVertexUniform: function createVertexUniform(type, node, ns, needsUpdate, label) {\n    return this.createUniform('vertex', type, node, ns, needsUpdate, label);\n  },\n  createFragmentUniform: function createFragmentUniform(type, node, ns, needsUpdate, label) {\n    return this.createUniform('fragment', type, node, ns, needsUpdate, label);\n  },\n  include: function include(node, parent, source) {\n    var includesStruct;\n    node = typeof node === 'string' ? NodeLib.get(node) : node;\n    if (this.context.include === false) {\n      return node.name;\n    }\n    if (node instanceof FunctionNode) {\n      includesStruct = this.includes.functions;\n    } else if (node instanceof ConstNode) {\n      includesStruct = this.includes.consts;\n    } else if (node instanceof StructNode) {\n      includesStruct = this.includes.structs;\n    }\n    var includes = includesStruct[this.shader] = includesStruct[this.shader] || [];\n    if (node) {\n      var included = includes[node.name];\n      if (!included) {\n        included = includes[node.name] = {\n          node: node,\n          deps: []\n        };\n        includes.push(included);\n        included.src = node.build(this, 'source');\n      }\n      if (node instanceof FunctionNode && parent && includes[parent.name] && includes[parent.name].deps.indexOf(node) == -1) {\n        includes[parent.name].deps.push(node);\n        if (node.includes && node.includes.length) {\n          var i = 0;\n          do {\n            this.include(node.includes[i++], parent);\n          } while (i < node.includes.length);\n        }\n      }\n      if (source) {\n        included.src = source;\n      }\n      return node.name;\n    } else {\n      throw new Error('Include not found.');\n    }\n  },\n  colorToVectorProperties: function colorToVectorProperties(color) {\n    return color.replace('r', 'x').replace('g', 'y').replace('b', 'z').replace('a', 'w');\n  },\n  colorToVector: function colorToVector(color) {\n    return color.replace(/c/g, 'v3');\n  },\n  getIncludes: function getIncludes(type, shader) {\n    return this.includes[type][shader || this.shader];\n  },\n  getIncludesCode: function () {\n    function sortByPosition(a, b) {\n      return a.deps.length - b.deps.length;\n    }\n    return function getIncludesCode(type, shader) {\n      var includes = this.getIncludes(type, shader);\n      if (!includes) return '';\n      var code = '',\n        includes = includes.sort(sortByPosition);\n      for (var i = 0; i < includes.length; i++) {\n        if (includes[i].src) code += includes[i].src + '\\n';\n      }\n      return code;\n    };\n  }(),\n  getConstructorFromLength: function getConstructorFromLength(len) {\n    return constructors[len - 1];\n  },\n  isTypeMatrix: function isTypeMatrix(format) {\n    return /^m/.test(format);\n  },\n  getTypeLength: function getTypeLength(type) {\n    if (type === 'f') return 1;\n    return parseInt(this.colorToVector(type).substr(1));\n  },\n  getTypeFromLength: function getTypeFromLength(len) {\n    if (len === 1) return 'f';\n    return 'v' + len;\n  },\n  findNode: function findNode() {\n    for (var i = 0; i < arguments.length; i++) {\n      var nodeCandidate = arguments[i];\n      if (nodeCandidate !== undefined && nodeCandidate.isNode) {\n        return nodeCandidate;\n      }\n    }\n  },\n  resolve: function resolve() {\n    for (var i = 0; i < arguments.length; i++) {\n      var nodeCandidate = arguments[i];\n      if (nodeCandidate !== undefined) {\n        if (nodeCandidate.isNode) {\n          return nodeCandidate;\n        } else if (nodeCandidate.isTexture) {\n          switch (nodeCandidate.mapping) {\n            case CubeReflectionMapping:\n            case CubeRefractionMapping:\n              return new CubeTextureNode(nodeCandidate);\n            case CubeUVReflectionMapping:\n            case CubeUVRefractionMapping:\n              return new TextureCubeNode(new TextureNode(nodeCandidate));\n            default:\n              return new TextureNode(nodeCandidate);\n          }\n        } else if (nodeCandidate.isVector2) {\n          return new Vector2Node(nodeCandidate);\n        } else if (nodeCandidate.isVector3) {\n          return new Vector3Node(nodeCandidate);\n        } else if (nodeCandidate.isVector4) {\n          return new Vector4Node(nodeCandidate);\n        }\n      }\n    }\n  },\n  format: function format(code, from, to) {\n    var typeToType = this.colorToVector(to + ' <- ' + from);\n    switch (typeToType) {\n      case 'f <- v2':\n        return code + '.x';\n      case 'f <- v3':\n        return code + '.x';\n      case 'f <- v4':\n        return code + '.x';\n      case 'f <- i':\n      case 'f <- b':\n        return 'float( ' + code + ' )';\n      case 'v2 <- f':\n        return 'vec2( ' + code + ' )';\n      case 'v2 <- v3':\n        return code + '.xy';\n      case 'v2 <- v4':\n        return code + '.xy';\n      case 'v2 <- i':\n      case 'v2 <- b':\n        return 'vec2( float( ' + code + ' ) )';\n      case 'v3 <- f':\n        return 'vec3( ' + code + ' )';\n      case 'v3 <- v2':\n        return 'vec3( ' + code + ', 0.0 )';\n      case 'v3 <- v4':\n        return code + '.xyz';\n      case 'v3 <- i':\n      case 'v3 <- b':\n        return 'vec2( float( ' + code + ' ) )';\n      case 'v4 <- f':\n        return 'vec4( ' + code + ' )';\n      case 'v4 <- v2':\n        return 'vec4( ' + code + ', 0.0, 1.0 )';\n      case 'v4 <- v3':\n        return 'vec4( ' + code + ', 1.0 )';\n      case 'v4 <- i':\n      case 'v4 <- b':\n        return 'vec4( float( ' + code + ' ) )';\n      case 'i <- f':\n      case 'i <- b':\n        return 'int( ' + code + ' )';\n      case 'i <- v2':\n        return 'int( ' + code + '.x )';\n      case 'i <- v3':\n        return 'int( ' + code + '.x )';\n      case 'i <- v4':\n        return 'int( ' + code + '.x )';\n      case 'b <- f':\n        return '( ' + code + ' != 0.0 )';\n      case 'b <- v2':\n        return '( ' + code + ' != vec2( 0.0 ) )';\n      case 'b <- v3':\n        return '( ' + code + ' != vec3( 0.0 ) )';\n      case 'b <- v4':\n        return '( ' + code + ' != vec4( 0.0 ) )';\n      case 'b <- i':\n        return '( ' + code + ' != 0 )';\n    }\n    return code;\n  },\n  getTypeByFormat: function getTypeByFormat(format) {\n    return convertFormatToType[format] || format;\n  },\n  getFormatByType: function getFormatByType(type) {\n    return convertTypeToFormat[type] || type;\n  },\n  getUuid: function getUuid(uuid, useCache) {\n    useCache = useCache !== undefined ? useCache : true;\n    if (useCache && this.cache) uuid = this.cache + '-' + uuid;\n    return uuid;\n  },\n  getElementByIndex: function getElementByIndex(index) {\n    return elements[index];\n  },\n  getIndexByElement: function getIndexByElement(elm) {\n    return elements.indexOf(elm);\n  },\n  isShader: function isShader(shader) {\n    return this.shader === shader;\n  },\n  setShader: function setShader(shader) {\n    this.shader = shader;\n    return this;\n  },\n  mergeDefines: function mergeDefines(defines) {\n    for (var name in defines) {\n      this.defines[name] = defines[name];\n    }\n    return this.defines;\n  },\n  mergeUniform: function mergeUniform(uniforms) {\n    for (var name in uniforms) {\n      this.uniforms[name] = uniforms[name];\n    }\n    return this.uniforms;\n  },\n  getTextureEncodingFromMap: function getTextureEncodingFromMap(map) {\n    var encoding;\n    if (!map) {\n      encoding = LinearEncoding;\n    } else if (map.isTexture) {\n      encoding = map.encoding;\n    } else if (map.isWebGLRenderTarget) {\n      console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\n      encoding = map.texture.encoding;\n    }\n    if (encoding === LinearEncoding && this.context.gamma) {\n      encoding = GammaEncoding;\n    }\n    return encoding;\n  }\n};\nexport { NodeBuilder };","map":null,"metadata":{},"sourceType":"module"}