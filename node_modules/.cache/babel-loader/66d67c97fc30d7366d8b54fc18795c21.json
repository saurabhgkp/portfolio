{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { StructNode } from '../core/StructNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { FunctionCallNode } from '../core/FunctionCallNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { MathNode } from '../math/MathNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nfunction TextureCubeUVNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new StructNode(\"struct TextureCubeUVData {\\n\\t\\t\\tvec4 tl;\\n\\t\\t\\tvec4 tr;\\n\\t\\t\\tvec4 br;\\n\\t\\t\\tvec4 bl;\\n\\t\\t\\tvec2 f;\\n\\t\\t}\");\n  var cubeUV_maxMipLevel = new ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new FunctionNode(\"float getFace(vec3 direction) {\\n\\t\\t\\t\\tvec3 absDirection = abs(direction);\\n\\t\\t\\t\\tfloat face = -1.0;\\n\\t\\t\\t\\tif (absDirection.x > absDirection.z) {\\n\\t\\t\\t\\t\\tif (absDirection.x > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (absDirection.z > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn face;\\n\\t\\t}\");\n  getFace.useKeywords = false;\n  var getUV = new FunctionNode(\"vec2 getUV(vec3 direction, float face) {\\n\\t\\t\\t\\tvec2 uv;\\n\\t\\t\\t\\tif (face == 0.0) {\\n\\t\\t\\t\\t\\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\\n\\t\\t\\t\\t} else if (face == 1.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\\n\\t\\t\\t\\t} else if (face == 2.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\\n\\t\\t\\t\\t} else if (face == 3.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\\n\\t\\t\\t\\t} else if (face == 4.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 0.5 * (uv + 1.0);\\n\\t\\t}\");\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new FunctionNode(\"TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\n\\n\\t\\t\\tfloat face = getFace(direction);\\n\\t\\t\\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\\n\\t\\t\\tmipInt = max(mipInt, cubeUV_minMipLevel);\\n\\t\\t\\tfloat faceSize = exp2(mipInt);\\n\\n\\t\\t\\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\\n\\n\\t\\t\\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\\n\\t\\t\\tvec2 f = fract(uv);\\n\\t\\t\\tuv += 0.5 - f;\\n\\t\\t\\tif (face > 2.0) {\\n\\t\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\t\\tface -= 3.0;\\n\\t\\t\\t}\\n\\t\\t\\tuv.x += face * faceSize;\\n\\t\\t\\tif(mipInt < cubeUV_maxMipLevel){\\n\\t\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t\\t}\\n\\t\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\t\\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\n\\t\\t\\tuv *= texelSize;\\n\\n\\t\\t\\tvec4 tl = texture2D(envMap, uv);\\n\\t\\t\\tuv.x += texelSize;\\n\\t\\t\\tvec4 tr = texture2D(envMap, uv);\\n\\t\\t\\tuv.y += texelSize;\\n\\t\\t\\tvec4 br = texture2D(envMap, uv);\\n\\t\\t\\tuv.x -= texelSize;\\n\\t\\t\\tvec4 bl = texture2D(envMap, uv);\\n\\n\\t\\t\\treturn TextureCubeUVData( tl, tr, br, bl, f );\\n\\t\\t}\", [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new ConstNode('float r0 1.0', true);\n  var v0 = new ConstNode('float v0 0.339', true);\n  var m0 = new ConstNode('float m0 -2.0', true);\n  var r1 = new ConstNode('float r1 0.8', true);\n  var v1 = new ConstNode('float v1 0.276', true);\n  var m1 = new ConstNode('float m1 -1.0', true);\n  var r4 = new ConstNode('float r4 0.4', true);\n  var v4 = new ConstNode('float v4 0.046', true);\n  var m4 = new ConstNode('float m4 2.0', true);\n  var r5 = new ConstNode('float r5 0.305', true);\n  var v5 = new ConstNode('float v5 0.016', true);\n  var m5 = new ConstNode('float m5 3.0', true);\n  var r6 = new ConstNode('float r6 0.21', true);\n  var v6 = new ConstNode('float v6 0.0038', true);\n  var m6 = new ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new FunctionNode(\"float roughnessToMip(float roughness) {\\n\\t\\t\\tfloat mip = 0.0;\\n\\t\\t\\tif (roughness >= r1) {\\n\\t\\t\\t\\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\n\\t\\t\\t} else if (roughness >= r4) {\\n\\t\\t\\t\\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\n\\t\\t\\t} else if (roughness >= r5) {\\n\\t\\t\\t\\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\n\\t\\t\\t} else if (roughness >= r6) {\\n\\t\\t\\t\\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\\n\\t\\t\\t}\\n\\t\\t\\treturn mip;\\n\\t\\t}\", defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\nTextureCubeUVNode.prototype = Object.create(TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n    var mipInt = new MathNode(mip, MathNode.FLOOR);\n    var mipF = new MathNode(mip, MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n    var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { TextureCubeUVNode };","map":null,"metadata":{},"sourceType":"module"}