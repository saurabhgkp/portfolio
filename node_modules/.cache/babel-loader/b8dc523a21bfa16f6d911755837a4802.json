{"ast":null,"code":"import _classCallCheck from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/cliffexpc63/my example/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nvar box1 = new Box3();\nvar box2 = new Box3();\nvar vec = new Vector3();\nexport var MeshBVHDebug = /*#__PURE__*/function () {\n  function MeshBVHDebug(bvh, geometry) {\n    _classCallCheck(this, MeshBVHDebug);\n\n    this.bvh = bvh;\n    this.geometry = geometry;\n  } // Returns a simple, human readable object that represents the BVH.\n\n\n  _createClass(MeshBVHDebug, [{\n    key: \"getJSONStructure\",\n    value: function getJSONStructure() {\n      var bvh = this.bvh;\n      var depthStack = [];\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          bounds: arrayToBox(boundingData, new Box3())\n        };\n\n        if (isLeaf) {\n          info.count = count;\n          info.offset = offset;\n        } else {\n          info.left = null;\n          info.right = null;\n        }\n\n        depthStack[depth] = info; // traversal hits the left then right node\n\n        var parent = depthStack[depth - 1];\n\n        if (parent) {\n          if (parent.left === null) {\n            parent.left = info;\n          } else {\n            parent.right = info;\n          }\n        }\n      });\n      return depthStack[0];\n    }\n  }, {\n    key: \"validateBounds\",\n    value: function validateBounds() {\n      var bvh = this.bvh,\n          geometry = this.geometry;\n      var depthStack = [];\n      var index = geometry.index;\n      var position = geometry.getAttribute('position');\n      var passes = true;\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          depth: depth,\n          isLeaf: isLeaf,\n          boundingData: boundingData,\n          offset: offset,\n          count: count\n        };\n        depthStack[depth] = info;\n        arrayToBox(boundingData, box1);\n        var parent = depthStack[depth - 1];\n\n        if (isLeaf) {\n          // check triangles\n          for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n            var i0 = index.getX(i);\n            var i1 = index.getX(i + 1);\n            var i2 = index.getX(i + 2);\n            var isContained = void 0;\n            vec.fromBufferAttribute(position, i0);\n            isContained = box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i1);\n            isContained = isContained && box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i2);\n            isContained = isContained && box1.containsPoint(vec);\n            console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n            passes = passes && isContained;\n          }\n        }\n\n        if (parent) {\n          // check if my bounds fit in my parents\n          arrayToBox(boundingData, box2);\n\n          var _isContained = box2.containsBox(box1);\n\n          console.assert(_isContained, 'Parent bounds does not fully contain child.');\n          passes = passes && _isContained;\n        }\n      });\n      return passes;\n    }\n  }]);\n\n  return MeshBVHDebug;\n}();","map":{"version":3,"names":["Box3","Vector3","arrayToBox","box1","box2","vec","MeshBVHDebug","bvh","geometry","depthStack","traverse","depth","isLeaf","boundingData","offset","count","info","bounds","left","right","parent","index","position","getAttribute","passes","i","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox"],"sources":["/home/cliffexpc63/my example/portfolio/node_modules/three-mesh-bvh/src/MeshBVHDebug.js"],"sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nconst box1 = new Box3();\r\nconst box2 = new Box3();\r\nconst vec = new Vector3();\r\n\r\nexport class MeshBVHDebug {\r\n\r\n\tconstructor( bvh, geometry ) {\r\n\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\t// Returns a simple, human readable object that represents the BVH.\r\n\tgetJSONStructure() {\r\n\r\n\t\tconst { bvh } = this;\r\n\t\tconst depthStack = [];\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tbounds: arrayToBox( boundingData, new Box3() ),\r\n\t\t\t};\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tinfo.count = count;\r\n\t\t\t\tinfo.offset = offset;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinfo.left = null;\r\n\t\t\t\tinfo.right = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\t// traversal hits the left then right node\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\t\tparent.left = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparent.right = info;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn depthStack[ 0 ];\r\n\r\n\t}\r\n\r\n\tvalidateBounds() {\r\n\r\n\t\tconst { bvh, geometry } = this;\r\n\t\tconst depthStack = [];\r\n\t\tconst index = geometry.index;\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\t\tlet passes = true;\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tdepth,\r\n\t\t\t\tisLeaf,\r\n\t\t\t\tboundingData,\r\n\t\t\t\toffset,\r\n\t\t\t\tcount,\r\n\t\t\t};\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\tarrayToBox( boundingData, box1 );\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t// check triangles\r\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i0 );\r\n\t\t\t\t\tisContained = box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i1 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i2 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t// check if my bounds fit in my parents\r\n\t\t\t\tarrayToBox( boundingData, box2 );\r\n\r\n\t\t\t\tconst isContained = box2.containsBox( box1 );\r\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn passes;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}